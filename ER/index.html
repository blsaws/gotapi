<!DOCTYPE html>

<html lang="en-us">
<head>
  <link href="gotapi.css" rel="stylesheet" type="text/css">

  <title>Generic Open Terminal API (GotAPI)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <!--
   To publish this document, see instructions in README
   -->

   <script src='js/require.js' data-main='js/profile-w3c-common' async class='remove'></script>
  <script class="remove" src="gotapi.js" type="text/javascript">
  <!-- keep this comment -->
  </script>
</head>

<body>
<section id='title'>
<img src="images/oma-logo.jpg"/>
<table style="width: 100%">
<tr><td style='float: right; font-size: 40px;'><b>Generic Open Terminal API Framework (GotAPI)</b></td>
<tr><td style='float: right; font-size: 40px;'>Draft Version 1.0 – 6 Jan 2014</td>
</td></table>
<hr style="height: 2px;" />
<table style="width: 100%"></td>
<tr><td style='float: right; font-size: 40px;'><b>Open Mobile Alliance<b></td>
<tr><td style='float: right; font-size: 40px;'>OMA-ER-GotAPI-V1_0-20150106-D</td></table>
</section>

<section id='copyright'>
<p class='copyright'>Use of this document is subject to all of the terms and conditions of the Use Agreement located at <a href="http://www.openmobilealliance.org/UseAgreement.html">http://www.openmobilealliance.org/UseAgreement.html</a>.<br/>Unless this document is clearly designated as an approved specification, this document is a work in process, is not an approved Open Mobile Alliance™ specification, and is subject to revision or removal without notice.<br/>You may use this document or any part of the document for internal or educational purposes only, provided you do not modify, edit or take out of context the information in this document in any manner.  Information contained in this document may be used, at your sole risk, for any purposes.  You may not use this document in any other manner without the prior written permission of the Open Mobile Alliance™,  The Open Mobile Alliance authorizes you to copy this document, provided that you retain all copyright and other proprietary notices contained in the original materials on any copies of the materials and that you comply strictly with these terms.  This copyright permission does not constitute an endorsement of the products or services.  The Open Mobile Alliance assumes no responsibility for errors or omissions in this document.<br/>Each Open Mobile Alliance member has agreed to use reasonable endeavors to inform the Open Mobile Alliance in a timely manner of Essential IPR as it becomes aware that the Essential IPR is related to the prepared or published specification.  However, the members do not have an obligation to conduct IPR searches.  The declared Essential IPR is publicly available to members and non-members of the Open Mobile Alliance and may be found on the OMA IPR Declarations list at <a href="http://www.openmobilealliance.org/ipr.html">http://www.openmobilealliance.org/ipr.html</a>.  The Open Mobile Alliance has not conducted an independent IPR review of this document and the information contained herein, and makes no representations or warranties regarding third party IPR, including without limitation patents, copyrights or trade secret rights.  This document may contain inventions for which you must obtain licenses from third parties before making, using or selling the inventions.  Defined terms above are set forth in the schedule to the Open Mobile Alliance Application Form.<br/>NO REPRESENTATIONS OR WARRANTIES (WHETHER EXPRESS OR IMPLIED) ARE MADE BY THE OPEN MOBILE ALLIANCE OR ANY OPEN MOBILE ALLIANCE MEMBER OR ITS AFFILIATES REGARDING ANY OF THE IPR’S REPRESENTED ON THE 'OMA IPR DECLARATIONS' LIST, INCLUDING, BUT NOT LIMITED TO THE ACCURACY, COMPLETENESS, VALIDITY OR RELEVANCE OF THE INFORMATION OR WHETHER OR NOT SUCH RIGHTS ARE ESSENTIAL OR NON-ESSENTIAL.<br/>THE OPEN MOBILE ALLIANCE IS NOT LIABLE FOR AND HEREBY DISCLAIMS ANY DIRECT, INDIRECT, PUNITIVE, SPECIAL, INCIDENTAL, CONSEQUENTIAL, OR EXEMPLARY DAMAGES ARISING OUT OF OR IN CONNECTION WITH THE USE OF DOCUMENTS AND THE INFORMATION CONTAINED IN THE DOCUMENTS.<br/>© 2015 Open Mobile Alliance Ltd.  All Rights Reserved.<br/>Used with the permission of the Open Mobile Alliance Ltd. under the terms set forth above.<br/></p>
<hr style="height: 2px;" />
</section>

<section id='abstract'>
<p>This Enabler Release (ER) document is a combined document that includes requirements, architecture and technical specification of the Generic Open Terminal API Framework (GotAPI) Enabler.</p>
<p>The scope of this enabler will include:</p>
<ul><td>Architecture and specifications for an API framework enabling web-based APIs to be exposed to apps running in web browsers and as native apps (including but not limited to hybrid native/web apps)<td>Supporting assets for the localhost API server framework, e.g. JavaScript libraries enabling abstractions of common API functions (e.g. discovery, access, and session management)<td>A registry of well-known API resources for OMA enablers, to be maintained as part of the OMNA<td>Specification of API exposure patterns that are in general globally applicable to native device platforms
</ul>
</section>

<section id="References">
<h2>References</h2>

<section id="Normative">
<h3>Normative References</h3>
<table class="oma2">
	<tr><td>[SCRRULES]</td>
		<td>“SCR Rules and Procedures”, Open Mobile Alliance™, OMA-ORG-SCR_Rules_and_Procedures, URL: <a href="http://www.openmobilealliance.org/">http://www.openmobilealliance.org/</a>
	<tr><td>[rfc2119]</td>
		<td>“Key words for use in RFCs to Indicate Requirement Levels”, S. Bradner, March 1997, URL: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>
	<tr><td>[CORS]</td>
		<td>“Cross-Origin Resource Sharing”, Worldwide Web Consortium (W3C), URL: <a href="http://www.w3.org/TR/cors/">http://www.w3.org/TR/cors/</a>
	<tr><td>[OMA DM]</td>
		<td>OMA Device Management V2.0", Open Mobile Alliance™, 10 Dec 2013, URL: <a href="http://technical.openmobilealliance.org/Technical/technical-information/release-program/current-releases/oma-device-management-v2-0">http://technical.openmobilealliance.org/Technical/technical-information/release-program/current-releases/oma-device-management-v2-0</a>
	<tr><td>[HTTP/1.1]</td>
		<td>“Hypertext Transfer Protocol -- HTTP/1.1”, Internet Engineering Task Force (IETF), URL: <a href="http://tools.ietf.org/search/rfc2616">http://tools.ietf.org/search/rfc2616</a>
	<tr><td>[JSON-RPC]</td>
		<td>“JSON-RPC 2.0 Specification”, JSON-RPC Working Group, URL: <a href="http://www.jsonrpc.org/specification">http://www.jsonrpc.org/specification</a>
	<tr><td>[OAuth2.0]</td>
		<td>“The OAuth 2.0 Authorization Framework”, Internet Engineering Task Force (IETF), URL: <a href="http://tools.ietf.org/html/rfc6749">http://tools.ietf.org/html/rfc6749</a>
	<tr><td>[RFC6454]</td>
		<td>“The Web Origin Concept”, Internet Engineering Task Force (IETF), URL: <a href="http://tools.ietf.org/html/rfc6454">http://tools.ietf.org/html/rfc6454</a>
	<tr><td>[XHR]</td>
		<td>“XMLHttpRequest Level 1”, Worldwide Web Consortium (W3C), URL: <a href="http://www.w3.org/TR/XMLHttpRequest/">http://www.w3.org/TR/XMLHttpRequest/</a>
	<tr><td>[HTTP2]</td>
		<td>"Hypertext Transfer Protocol version 2", Internet Engineering Task Force (IETF), URL: <a href=" https://tools.ietf.org/html/draft-ietf-httpbis-http2">https://tools.ietf.org/html/draft-ietf-httpbis-http2</a>
	<tr><td>[WebSocket]</td>
		<td>"The WebSocket API", Worldwide Web Consortium (W3C), URL: <a href="http://www.w3.org/TR/websockets/">http://www.w3.org/TR/websockets/</a>
	<tr><td>[WebSocketProtocol]</td>
		<td>"The WebSocket Protocol", Internet Engineering Task Force (IETF), URL: <a href=" https://tools.ietf.org/html/rfc6455">https://tools.ietf.org/html/rfc6455</a>
	<tr><td>[SSE]</td>
		<td>"Server-Sent Events", Worldwide Web Consortium (W3C), URL: <a href=" http://www.w3.org/TR/eventsource/">http://www.w3.org/TR/eventsource/</a>
	<tr><td>[WebRTC]</td>
		<td>"WebRTC 1.0: Real-time Communication Between Browsers", Worldwide Web Consortium (W3C), URL: <a href=" http://www.w3.org/TR/webrtc/">http://www.w3.org/TR/webrtc/</a>
	<tr><td>[Rtcweb]</td>
		<td>"Rtcweb", Internet Engineering Task Force (IETF), URL: <a href="http://tools.ietf.org/wg/rtcweb/">http://tools.ietf.org/wg/rtcweb/</a>
</table>

</section>

<section id="Informative">
<h3>Informative References</h3>

<table class="oma2">
	<tr><td>[OMADICT]</td>
		<td>“Dictionary for OMA Specifications”, Version 2.8, Open Mobile Alliance™,OMA-ORG-Dictionary-V2.8, URL: <a href="<a href="http://www.openmobilealliance.org/">http://www.openmobilealliance.org/</a>
	<tr><td>[OMNA]</td>
		<td>"OMA Naming Authority". Open Mobile Alliance™, URL: <a href="http://www.openmobilealliance.org/tech/omna.aspx">http://www.openmobilealliance.org/tech/omna.aspx</a>
	<tr><td>[RFC6454]</td>
		<td>“The Web Origin Concept”, URL: <a href="https://www.ietf.org/rfc/rfc6454.txt">https://www.ietf.org/rfc/rfc6454.txt</a>
	<tr><td>[RFC6973]</td>
		<td>“Privacy Considerations for Internet Protocols”, A. Cooper, et al, July 2013, URL: <a href=" http://tools.ietf.org/html/rfc6973">http://tools.ietf.org/html/rfc6973</a>
</table>
</section>
</section>

<section id="Terminology">
<h2>Terminology and Conventions</h2>

<section id="Conventions">
<h3>Conventions</h3>
<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [[rfc2119]].</p>
<p>All sections and appendixes, except “Scope” and “Introduction”, are normative, unless they are explicitly indicated to be informative.</p>

</section>

<section id="Definitions">
<h3>Definitions</h3>
<table class="oma2">
	<tr><td>API Patterns</td><td>Design guidelines and requirements for definition of APIs
	<tr><td>Hybrid Native/Web App</td><td>An application designed to execute under the native OS / middleware environment of a device, and that use native APIs for the execution of web content in addition to native code.
	<tr><td>JavaScript</td><td>Use definition from [OMADICT].
	<tr><td>Native App</td><td>An application designed to execute under the native OS / middleware environment of a device.
	<tr><td>User Agent</td><td>Use definition from [OMADICT].
	<tr><td>Web</td><td>The World Wide Web, a content and application framework based upon hypertext and related technologies, e.g. XML, JavaScript/ECMAScript, CSS, etc.
	<tr><td>Web Application</td><td>An application designed using Web technologies (e.g. HTML, CSS, and Javascript).
	<tr><td>WebSocket</td><td>An API providing networking services per the WebSocket standard [WebSocket].
	<tr><td>Uniform Resource Identifier</td><td>Use definition from [OMADICT].
</table>
</section>

<section id="Abbreviations">
<h3>Abbreviations</h3>
<table class="oma2">
	<tr><td>API</td><td>Application Programming Interface
	<tr><td>HTTP</td><td>HyperText Transfer Protocol
	<tr><td>JSON</td><td>JavaScript Object Notation
	<tr><td>MIME</td><td>Multipurpose Internet Mail Extensions
	<tr><td>OMA</td><td>Open Mobile Alliance
	<tr><td>REST</td><td>REpresentational State Transfer
	<tr><td>RPC</td><td>Remote Procedure Call
	<tr><td>SCR</td><td>Static Conformance Requirements
	<tr><td>TS</td><td>Technical Specification
	<tr><td>UA</td><td>User Agent
	<tr><td>URI</td><td>Uniform Resource Identifier
	<tr><td>URL</td><td>Uniform Resource Locator
	<tr><td>W3C</td><td>World Wide Web Consortium
	<tr><td>WRAPI</td><td>The OMA Web Runtime API enabler
</table>
</section>
</section>

<section id="introduction">
<h2>Introduction</h2>
<p>The concept of a common OMA device API framework, through which OMA enablers can be exposed to applications executing in various execution environments, has been a discussion thread in OMA for several years. For the web, the discussion started with Client Side Enabler API [CSEA] work item, and followed by the Web Runtime API [WRAPI] work item which established an initial pattern for OMA API exposure to web applications, focused on the requirements of the OMA Push enabler. The need for more broadly applicable API patterns was recognized during development of APIs for the Mobile Codes 2.0 [MCAPI] enabler and the Open Connection Management 1.1 API [CMAPI] enabler. Interest in incorporating the WRAPI local API server concept has further been expressed for the RCS-enabling enablers of COM, and the Device Management enablers, among others.</p> 
<p>This specification defines a variety of API exposure patterns for use in development of OMA enablers, and the functions required by API servers that support those exposure patterns. APIs designed per these patterns are intended to be “web-based” (i.e. accessed via the use of web technologies) and exposed to apps running in the following contexts:</p>
<ul>
	<li>Web Browser apps, i.e. web apps running in a window of a web browser
	<li>Web  Runtime apps, i.e. web apps running outside a browser, e.g. under a Widget Engine or other “chromeless” runtime for execution of web content as standalone apps
	<li>Hybrid Native/Web apps, i.e. apps that run web content through native APIs for that purpose
	<li>Native Apps that directly use native platform APIs enabling use of the web-related protocols described in this document. Though not leveraging a full web execution environment, such apps can use the same network-based APIs as web apps.
</ul>
<p>For simplicity, the web API client environment provided by each of these contexts is referred to here as the User Agent (UA). The OMA enabler clients that expose APIs via the GotAPI patterns are referred to here as the GotAPI Server. GotAPI Servers may also act as Auth servers for other GotAPI Servers, and in that role are referred to here as GotAPI Auth Servers.</p>
<p>The web-based methods defined by GotAPI are intended to offer a flexible set of options for OMA enablers to expose their services to apps via web-based APIs. Such APIs are primarily intended to be exposed to apps running in the device hosting the OMA enabler client, but in principle could also be exposed to apps in other devices that are networked with the OMA enabler client host device.</p>
<p>The exposure of OMA enabler-based services via such web-based APIs is intended to broaden the reach of OMA enabler deployments, by making it possible for web apps to access them, without explicit UA support of APIs specifically designed per the requirements of OMA enablers.</p>
<p>The figure below illustrates the relationships and conceptual interfaces between web apps, the UA, GotAPI-specified functions (shaded), and other OMA-specified functions.</p>

<figure id="l" style="display: table; width: 60%; text-align: center;">
<figcaption><b>Conceptual Implementation (Informative)</b></figcaption>
<img src="images/Conceptual_Implementation_Informative.png" style="width: 80%; align: center;"/>
</figure>

<p>In the figure above:
<ul>
	<li>The GotAPI functions include the GotAPI Server (including optionally acting as a distinct Auth server) and a database of API access permissions.
	<li>The device OS provides intra-device and inter-device communication via network protocols such as HTTP, WebSocket, Server-Sent Events, and WebRTC, via which the web-based APIs can be exposed.
	<li>The access permissions database is logically specified per its supporting operations and policy structure, but interfaces to it are unspecified by GotAPI. 
	<li>Interfaces to other OMA enabler clients are also unspecified.
	<li>GotAPI Servers may expose APIs for multiple OMA enablers, and either directly implement the related OMA enabler functions or as above use unspecified interfaces exposed by the specific OMA enabler clients.
	<li>User interface functions can include a variety of means for assessing user consent for API access by apps, including basic means such as device display and keyboard, or more advanced means such as Trusted User Interfaces (TUI) or biometrics. 
</ul></p>
</section>

<section id="version1.0">
<h2>Version 1.0</h2>
<p>GotAPI version 1.0 includes the functionality:
<ul>
	<li>Architecture and specifications for GotAPI Servers and GotAPI Auth Servers in an API framework enabling web-based APIs to be exposed apps running in web browsers and as native apps (including but not limited to hybrid native/web apps)
	<li>Supporting assets for the localhost API server framework, e.g. JavaScript libraries enabling abstractions of common API functions (e.g. discovery, access, and session management)
	<li>A registry of well-known API resources for OMA enablers, to be maintained as part of the OMNA
	<li>Specification of API exposure patterns that are in general globally applicable to native device platforms
</ul></p>
</section>

<section id="release_description">
<h2>GotAPI Enabler release description (Informative)</h2>
<p>This release focuses on:
<ul>
	<li>the functions of GotAPI Servers and GotAPI OAuthAuth Servers, through which OMA enabler based services can be exposed and access to the APIs managed
	<li>the Extension Plug-Ins for external devices and internal enablers through which they communicate with the GotAPI Server
</ul></p>
</section>

<section id="requirements">
<h2>Requirements (Normative)</h2>
<section id="highlevel-requirements">
<h3>High-Level Functional Requirements</h3>
<p>The following requirements outline the high-level set of options that GotAPI Servers may implement. The GotAPI technical specifications will address the necessary functions for support of these options.</p>

<table class="oma1">
<caption>High-Level Functional Requirements</caption>
<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
<thead>
<th>Label
<th>Description
<th>Release</thead>
<tr><td>GotAPI-HLF-01<td>GotAPI Servers SHALL support APIs exposed via HTTP/1.1 [HTTP/1.1].<td>1.0
<tr><td>GotAPI-HLF-02<td>GotAPI Servers SHALL support APIs exposed via custom URI scheme handlers.<td>&gt;1.0
<tr><td>GotAPI-HLF-03<td>GotAPI Servers MAY support APIs exposed via the WebSocket API [WebSocket].<td>1.0
<tr><td>GotAPI-HLF-04<td>GotAPI Servers MAY support APIs exposed via Server-Sent Events [SSE].<td>1.0
<tr><td>GotAPI-HLF-05<td>GotAPI Servers MAY support APIs exposed via the WebRTC API [WebRTC].<td>1.0
<tr><td>GotAPI-HLF-06<td>GotAPI Servers MAY support APIs exposed via HTTP/2.0  [HTTP/2.0].<td>1.0
<tr><td>GotAPI-HLF-07<td>GotAPI Servers SHALL support APIs exposed using the REST design pattern.<td>1.0
<tr><td>GotAPI-HLF-08<td>GotAPI Servers MAY support APIs exposed using the RPC design pattern, including APIs exposed using JSON-RPC 2.0 [JSON-RPC] as payload protocol.<td>1.0
<tr><td>GotAPI-HLF-09<td>GotAPI Servers MAY support APIs that include transfer of any discrete media type.<td>1.0
<tr><td>GotAPI-HLF-10<td>GotAPI Servers MAY support APIs that include transfer of any streamed media type.<td>1.0
<tr><td>GotAPI-HLF-11<td>GotAPI Servers SHALL expose APIs to UAs in the GotAPI Server host device.<td>1.0
<tr><td>GotAPI-HLF-12<td>GotAPI Servers MAY expose APIs to UAs in devices other than the GotAPI Server host device.<td>&gt;1.0
<tr><td>GotAPI-HLF-13<td>Multiple GotAPI Servers SHALL be implementable and functional simultaneously on a device where possible.<td>&gt;1.0
<tr><td>GotAPI-HLF-14<td>GotAPI SHALL support an API that provides applications with availability of GotAPI in the device in response to query requests from the application.<td>1.0
<tr><td>GotAPI-HLF-15<td>GotAPI Servers SHALL support invocation via a custom URI scheme, to startup the server when it is not running.<td>1.0
<tr><td>GotAPI-HLF-16<td>GotAPI Server SHALL expose an interface to communicate with external devices and internal enablers, so that different manufacturers are able to develop Extension Plug-Ins for the GotAPI Server, and application developers are able to develop applications that can communicate with such other external devices and internal enablers through GotAPI Server. Note: The APIs for each device or enabler are out of the scope of this specification.<td>1.0
</table>
</section>

<section id="security-privacy">
<h3>Security and Privacy</h3>
<p>The following requirements address the generic security and privacy enabling features of GotAPI Servers.</p>

<table class="oma1">
<caption>High-Level Functional Requirements – Security and Privacy Items</caption>
<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
<thead>
<th>Label
<th>Description
<th>Release</thead>
<tr><td>GotAPI-SEC-01<td>For clients in the host device, GotAPI Servers MAY support APIs exposed over TLS 1.2-secured connections.<td>&gt;1.0
<tr><td>GotAPI-SEC-02<td>For clients in other devices, GotAPI Servers SHALL support APIs exposed over TLS 1.2-secured connections.<td>&gt;1.0
<tr><td>GotAPI-SEC-03<td>GotAPI Servers SHALL support measures to minimize security risks including Intrusion and Denial-of-Service attacks.	<td>1.0
</table>
</section>

<section id="Authentication-Authorization">
<h3>Authentication and Authorization</h3>
<p>The following requirements address the ability of GotAPI Servers to identify API client apps and manage access to APIs.</p>
<table class="oma1">
<caption>High-Level Functional Requirements – Authentication and Authorization Items</caption>
<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
<thead>
<th>Label
<th>Description
<th>Release</thead>
<tr><td>GotAPI-AUTH-01<td>GotAPI Servers SHALL support Cross-Origin Resource Sharing.<td>1.0
<tr><td>GotAPI-AUTH-02<td>GotAPI Servers SHALL support management of API access permissions.<td>1.0
<tr><td>GotAPI-AUTH-03<td>GotAPI Servers MAY support OAuth-based API access.<td>1.0
<tr><td>GotAPI-AUTH-04<td>GotAPI Servers MAY act as an OAuth 2.0 [OAuth2.0] server for authorization of API access permissions.<td>1.0
<tr><td>GotAPI-AUTH-05<td>GotAPI Servers MAY support user interfaces (UI) via which users authorize API access permissions.<td>1.0
<tr><td>GotAPI-AUTH-06<td>GotAPI Servers MAY support pre-configured, fixed API access permissions.<td>1.0
<tr><td>GotAPI-AUTH-07<td>GotAPI Servers MAY support dynamic, updatable API access permissions.<td>1.0
<tr><td>GotAPI-AUTH-08<td>GotAPI Servers MAY support API access permissions managed through OMA Device Management.<td>&gt;1.0
</table>
</section>

<section id="Data Integrity">
<h3>Data Integrity</h3>
<p>The following requirements address the ability of GotAPI Servers to protect the integrity of data transferred via APIs.</p>
<table class="oma1">
<caption>High-Level Functional Requirements – Data Integrity Items</caption>
<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
<thead>
<th>Label
<th>Description
<th>Release</thead>
<tr><td>GotAPI-DATI-01<td>GotAPI Servers SHOULD support data integrity for all data exchanged with clients.<td>1.0
<tr><td>GotAPI-DATI-02<td>GotAPI Servers SHOULD support data integrity verification via digitally signed API request/response payloads,<td>1.0
</table>
</section>

<section id="Confidentiality">
<h3>Confidentiality</h3>
<p>The following requirements address the ability of GotAPI Servers to protect the confidentiality of data transferred via APIs.</p>
<table class="oma1">
<caption>High-Level Functional Requirements – Confidentiality Items</caption>
<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
<thead>
<th>Label
<th>Description
<th>Release</thead>
<tr><td>GotAPI-CONF-01<td>GotAPI Servers SHOULD support confidentiality for all data exchanged with clients.<td>1.0
<tr><td>GotAPI-CONF-02<td>GotAPI Servers SHOULD support data confidentiality via encrypted API request/response payloads,<td>1.0
</table>
</section>
</section>

<section id="Architectural-Model">
<h1>Architectural Model</h2>
<p>This section describes the architectural model and related aspects of the GotAPI Enabler.</p>
<p>The architecture definition and functionalities are based on the requirements defined in the Section 6.</p>

<section id="Architectural-Diagram">
<h2>Architectural Diagram</h2>
<figure id="2" style="display: table; width: 60%; text-align: center;">
<figcaption><b>GotAPI Architectural Diagram</b></figcaption>
<img src="images/Architecture_Diagram.png" style="width: 80%; align: center;"/>
</figure>
</section>

<figure id="3" style="display: table; width: 60%; text-align: center;">
<figcaption><b>GotAPI Architectural Diagram - Informative</b></figcaption>
<img src="images/Architecture_Diagram_Informative.png" style="width: 80%; align: center;"/>
</figure>

<p>The diagrams above are not implementation diagrams but logical diagrams. In practice, the GotAPI Server and the GotAPI Auth Server are implemented as a single application which is called as "GotAPI application". The GotAPI 1.0 specification assumes this implementation model. Namely, both servers listen to the same port number on one IP address.</p>
<p>Theoretically, it's possible to implement the GotAPI Server and the GotAPI Auth Server as separate applications. But this implementation model is not supported in the GotAPI 1.0 specification.</p>

<section id="Architectural-Diagram">
<h2>Functional Components and Interfaces/reference points definition</h2>

<section id="Functional-Components">
<h3>Functional Components</h2>
<section id="GotAPI-Server">
<h4>GotAPI Server</h4>
<p>The GotAPI Server provides the following functions:
<ul>
	<li>Exposure of the GotAPI-1 interface, via which Applications can issue API requests and receive responses
	<li>Binding of the GotAPI-1 interface to various specific interface technologies and payload protocols / design patterns. 
	<li>Security and privacy protection for requests via the GotAPI-1 interface
	<li>Protection of the GotAPI-1 interface from Server Spoofing, Intrusion and Denial of Service attacks
	<li>Exposure of the GotAPI-4 interface, via which Extension Plug-Ins can receive API requests from applications and send responses to applications through the GotAPI Server
	<li>Security and privacy protection for requests via the GotAPI-4 interface
	<li>Protection of the GotAPI-4 interface from Intrusion and Denial of Service attacks
</ul></p>

<p>Web applications running on web browsers have to use the XMLHttpRequest to send requests to the GotAPI Server on the GotAPI-1 interface. The origin of the web application is different from the origin of the GotAPI Server. Therefore, the GotAPI Server SHALL support Cross-Origin Resource Sharing [CORS] so that the web browser allows the web application to send HTTP requests to the GotAPI Server (i.e. cross-origin requests).</p>
</section>

<section id="GotAPI-Authorization-Server">
<h4>GotAPI Authorization Server</h4>
<p>The GotAPI Authorization Server provides the following functions:
<ul>
	<li>Exposure of the GotAPI-2 interface, via which Applications can obtain authorization to make API requests
	<li>User Interface functions as required to locally provide user information and consent for API access by applications
	<li>Acting as a proxy for user consent obtained through host-device external functions (e.g. OAuth servers)
	<li>Database of authorizations and user consent history
	<li>Binding of the GotAPI-2 interface to various specific interface technologies and payload protocols / design patterns. 
	<li>Security and privacy protection for requests via the GotAPI-2 interface
	<li>Protection of the GotAPI-2 interface from application identity spoofing, server spoofing, Intrusion and Denial of Service attacks
	<li>Optionally,exposure of the GotAPI-3 interface via which GotAPI authorizations can be provisioned through OMA Device Management or an implementation-specific policy management service
</ul></p>

<p>Web applications running on web browsers have to use the XMLHttpRequest to send requests to the GotAPI Authorization Server on the GotAPI-2 interface. The origin of the web application is different from the origin of the GotAPI Authorization Server. Therefore, the GotAPI Authorization Server SHALL support Cross-Origin Resource Sharing [CORS] so that the web browser allows the web application to send HTTP requests to the GotAPI Authorization Server (i.e. cross-origin requests).</p>
</section>
</section>

<section id="Interfaces">
<h3>Interfaces</h3>

<section id="GotAPI-1">
<h4>GotAPI-1</h4>
<p>The GotAPI-1 interface enables applications to make API requests and receive responses. This interface is generically specified by GotAPI, as GotAPI-based API specifications will define specific request/response transactions that can be utilized in host devices based upon the available interface technologies, payload protocols, and their applicable design patterns. These options include:
<ul>
	<li>The interface technologies TLS 1.2, HTTP/1.1, HTTP/2, WebSocket, Server-Sent Events, WebRTC
	<li>The design patterns REST and JSON, such as JSON-RPC
	<li>The Temporary Server Feed (TSF) mechanism for binary data and triggering a different protocols, as described below
</ul></p>

<p>The GotAPI Server SHALL support HTTP/1.1 as a communication protocol on the GotAPI-1 interface.</p>
<p>Additionally, the GotAPI Server MAY support HTTP/2 [HTTP2], WebSocket [WebSocket] [WebSocketProtocol], Server-Sent Events [SSE], and WebRTC [WebRTC][Rtcweb] as needed.</p>
<p>For example, if the GotAPI Server provides an API for enabling asynchronous notifications such as an event listener (One-way push API), the API can use Server-Sent Events.</p>

<figure id="2" style="display: table; width: 60%; text-align: center;">
<figcaption><b>One shot API and One-way push API</b></figcaption>
<img src="images/One_shot_API_and_One-way_push_API.png" style="width: 80%; align: center;"/>
</figure>

<p>If the GotAPI Server provides an API for enabling full-duplex real-time communications such as a chat service, the API can use WebSocket. WebSocket, however, requires another port numbers in addition to 4035/4036 for HTTP/HTTPS to be assigned. This specification does not specify the port numbers for WebSocket (ws: and wss:). Therefore, the GotAPI Server is encouraged to use the TSF mechanism described in the next section for such APIs.</p>
<p>The GotAPI Server SHALL support JSON as a data container format on the GotAPI-1 interface. Additionally, the GotAPI Server MAY support JSON-RPC [JSON-RPC] as needed.</p>

<section id="tsf">
<h5>The Temporary Server Feed (TSF) Mechanism</h5>
<p>There are two possible approaches which the GotAPI Server returns API result data to applications:
<ul>
	<li>Direct response approach:
	<ul>
		<li>GotAPI Server returns binary data as a response directly
		<li>This approach is very common and GotAPI-1 already supports it
	</ul>
	<li>Temporary Server Feed (TSF) approach:
	<ul>
		<li>When an app request something to the GotAPI Server on GotAPI-1, the GotAPI Server creates a temporary URI for the requested data, then return it to the app with additional information
		<li>Then the app accesses the URI in order to fetch the binary data
	</ul>
</ul></p>

<p>The TSF approach has advantages below:
<ul>
	<li>Flexible API design
	<ul>
		<li>The TSF mechanism brings flexibility to API design for GotAPI-1
		<li>APIs can provide additional information relevant to the requested binary data with applications
		<li>For example, APIs can provide adaptive streaming protocols over HTTP, such as SME + MPEG-DASH
		<ol>
			<li>An application requests MPD (Media Presentation Description) data over GotAPI-1
			<li>The application fetches fragments of the video data sequentially following the URLs defined in the MPD
		</ol>
	</ul>
	<li>Web developer friendly
		<ul>
			<li>Lots of existing server-side Web APIs on the Internet provide APIs similar to TSF with developers
		</ul>
	</ul>
</ul>

<p>The GotAPI Server MAY support the TSF mechanism.</p>
<p>If the GotAPI Server supports the TSF mechanism, the GotAPI Server SHALL support the following steps for data retrieved via a TSF:
<ol>
	<li>An application sends a request for accessing certain data to the GotAPI Server over the GotAPI-1.
	<li>When the GotAPI Server receives the request, the GotAPI Server creates a non-predictable random URI for the binary data that is requested, and associates the URI with the binary data. The port number of the URI is not necessarily 4035 or 4036. The GotAPI Server MAY decide the port number of the URI appropriately as needed.
	<li>The GotAPI Server sends a response with the URI and additional information (if needed) to the application over the GotAPI-1.
	<li>Receiving the URI, the application accesses the URI in order to get the requested binary data from the GotAPI Server. The GotAPI Server works as a Web server.
	<li>The GotAPI Server discards the URI after the application gets the binary data and/or after certain while for the purpose of security.
</ol></p>

<p>Example:</p>

<figure id="4" style="display: table; width: 100%; text-align: center;">
<figcaption><b>The TSF Procedure</b></figcaption>
<img src="images/The_TSF_Procedure.png" style="width: 80%; align: center;"/>
</figure>

<p>The JSON data and some URIs in the diagram above are just sample code. What protocol/format is used for the GotAPI-1 depends on the GotAPI enabler implementation, and is out of the scope of this specification.GotAPI-2.</p>
<p>Though the example in the figure above shows thea case where HTTP is used, the GotAPI Server MAY use HTTP/2, WebSocket, Server-Sent Events, and WebRTC as needed.</p>
<p>The TSF mechanism can be used for triggering communications using these protocols as well as transferring binary data. The GotAPI Server MAY use the TSF mechanism for other types of data and triggering other protocols.</p>
<p>For example, if the GotAPI Server provides an API for enabling full-duplex real-time communications such as a chat service, the GotAPI Server can use WebSocket instead of HTTP GET.</p>

<figure id="4" style="display: table; width: 100%; text-align: center;">
<figcaption><b>WebSocket used for TSF</b></figcaption>
<img src="images/WebSocket_used_for_TSF.png" style="width: 80%; align: center;"/>
</figure>

</section>
</section>

<section id="GotAPI-2">
<h4>GotAPI-2</h4>
<p>The GotAPI-2 interface enables applications to obtain authorization for access to GotAPI-based APIs. This interface is fully specified by GotAPI, being a common (though optionally used) support function for all GotAPI-based APIs. GotAPI-2 supports bindings and request/response transactions that can be utilized in host devices based upon the available interface technologies. These options include the interface technologies TLS 1.2, HTTP/1.1, HTTP/2, and URI scheme handling.</p>
<p>The GotAPI-2 interface is based upon the concepts of OAuth, though with different semantics as necessary for adaptation to the available interface technologies.</p>
<p>In this specification, an "origin" is an identifier of an application, which is globally unique.</p>
<p>If the application is a web application, the origin is literally an origin as defined by RFC6454, which is a concatenating string that is composed of the scheme, the fully qualified host name, and the TCP port number. For example, if the URL of a web application is "https://app.example.com:443/index.html", the origin is "https://app.example.com:443".
<ul>
	<li>If the application is an OS-specific native application, the origin is an application identifier managed by the underlying OS, such as a package name. For example, if the OS is Android, the origin could be "com.example.app".
	<li>If the application is a Hybrid Native/Web App, it is treated as an OS-specific native application by the underlying OS. Therefore the origin is an application identifier managed by the underlying OS, such as a package name.
</ul></p>
<p>The origin is embedded in the HTTP request header by the application itself or by the web browser automatically as described in the section "8.7 GotAPI Authorization Server".</p>
<p>The authenticity of the origin of the application is crucial for the entire operation of the GotAPI system.</p>
<p>The GotAPI Auth Server SHALL be able to extract the origin from the HTTP request header appropriately.</p>

<section id="Basic-GotAPI-2-Interface-Procedures">
<h5>Basic GotAPI-2 Interface Procedures</h5>
<p>The GotAPI-2 Interface must be able to run the steps as follows:
<ol>
	<li>Authorization of application
	<ul>
		<li>The application sends an authorization request to the GotAPI Auth Server with the origin. 
		<li>The GotAPI Auth Server MAY support a white-list of origins that have been pre-authenticated by the GotAPI service provider. If the GotAPI Auth Server supports such a white-list and the origin is listed in the white-list, the GotAPI Auth Server MAY determine if the application is acceptable or not.
		<li>If the GotAPI Auth Server accepts the application, the GotAPI Auth Server SHALL create a series of random digits, called as “grant”, that is long enough not to be predicted, and, then, SHALL send the response to the application with the grant.
	</ul>
	<li>Issuance of an access token
	<ul>
		<li>When the application receives the grant from the GotAPI Auth Server, it immediately sends an access token request to the GotAPI Auth Server with the origin, the grant, and the scope which is a list of functions the application wants to use. When the GotAPI Auth Server receives the request, the GotAPI Auth Server SHALL ask the user if the application may use the requested scope (the list of functions). In practice, the GotAPI Auth Server shows an OS-specific dialog box to the user.
		<li>The GotAPI Auth Server SHALL show the items in the dialog box as below:
		<ul>
			<li>The information of the application (e.g. the origin of the web application or the package name of the OS-specific native application)
			<li>The list of the functions which the application want to use (scope)
			<li>A button which the user presses if the user accepts the application
			<li>A button which the user presses if the user declines the application
		</ul>
		<li>If the user declines the request, the GotAPI Auth Server SHALL NOT allow the application to proceed any further beyond the point.
		<li>When the GotAPI Auth Server accepts the request, the GotAPI Auth Server SHALL create an access token for the application, which is a series of random digits that is long enough not to be predicted. Then the GotAPI Auth Server SHALL send the response with the access token to the application.
		<li>The application subsequently sends API requests with the access token on the GotAPI-1 Interface.
	</ul>
</ol></p>
</section>

<section id="Security-Enforced-GotAPI-2-Interface-Procedures">
<h5>Security-Enforced GotAPI-2 Interface Procedures</h5>
<p>In addition to the basic GotAPI-2 Interface procedures as described above, there are two security concerns for the GotAPI-2 Interface that needs to be addressed.
<ul>
	<li>GotAPI Auth Server spoofing
	<li>Application’s origin spoofing
</ul>

<p style="text-decoration: underline">GotAPI Auth Server spoofing:
<ul>
	<li>GotAPI Auth Server spoofing is an attack where a bogus GotAPI Auth Server takes over the genuine GotAPI Auth Server and pretends as if it was the GotAPI Auth Server. When the application sends a request to the GotAPI Server for the first time, there may even be a case where the GotAPI Server has already been taken over by the attacker.
	<li>Since GotAPI Auth Server spoofing is an easy-to-do attack, applications need to be able to verify if the GotAPI Auth Server is genuine or not. The HMAC server authentication resolves this spoofing attack.
	<li>The GotAPI Auth Server SHOULD be able to support the HMAC server authentication using the Trusted Channel with the Application ID as described in <a href="#7.3.3.3">section 7.3.3.3</a>
</ul></p>
<p style="text-decoration: underline">Application origin spoofing:
<ul>
	<li>Application origin spoofing is an attack where a malicious application acts as other application by sending a fake identity (a.k.a. origin) to the GotAPI Auth Server. The GotAPI Auth Server needs to be able to verify if the identity that it has received from the application is authentic or not.
	<li>When an application sends a request for authentication over the GotAPI-2 Interface, the origin of the application is included in the HTTP request header.
	<li>If the application is a web application running on a web browser, the application cannot override the Origin header in the HTTP request header [W3C XHR]. Therefore, the origin coming from a web application is trustable.
	<li>On the other hand, if the application is an OS-specific native application, the application may send a fake identity in the HTTP request header. Besides, a malicious native application may set the Origin header to be a fake origin pretending a web application running on a web browser.
	<li>When an application sends a request for authentication, the GotAPI Auth Server SHOULD be able to verify the origin coming from the application to determine if the origin is authentic or not.
	<li>The verification needs to depend on the features of the underlying OS domain on which the GotAPI Auth Server is running.
</ul></p>

<p>An example of such a verification mechanism if the underlying OS is Android: 
<ul>
	<li>Android supports the netstat command by default. But it does not provide the process ID of the native application establishing the HTTP connection.
	<li>Using Android NDK, however, the full-featured netstat can be built and packaged within an Android native application (i.e., GotAPI Server application).
	<li>The GotAPI Auth Server embedding the full-featured netstat identifies the process ID of the native application from the result of the full-featured netstat, and it can get the package name and application name from the process ID using the Android API.
	<li>The GotAPI Auth Server uses a white-list of application names of legitimate browsers that have been verified to be compliant to the origin header’s not-over-ridden requirements [W3C XHR]. The white-list enables the GotAPI Auth Server to distinguish the case of (i) a web application declaring an origin from (ii)  a malicious native application fakes origin header to pretend a web application.
</ul></p>

<p>The Table below shows all the cases where an attacking native application, com.attacker.app, declares various origins in the HTTP header and what the netstat can find. As shown in the table, the faked origins can be completely found by the netstat.</p>

<table class="oma1">
<caption>Cases of origins declaration by attacking native application and what the netstat can find</caption>
<col style="width: 20%"/><col style="width: 20%"/><col style="width: 20%"/><col style="width: 20%"/><col style="width: 20%"/>
<thead>
<th>Real package name
<th>Declared origin in HTTP header
<th>True/Fake
<th>What netstat finds
<th>Results
<th>Notes</thead>
<tr><td>com.attacker.app<td>http://example.com<td>Fake<td>com.attacker.app<td>Fake found<td>*1
<tr><td>com.attacker.app<td>com.example.app<td>Fake<td>com.attacker.app<td>Fake found<td>*2
<tr><td>com.attacker.app<td>com.attacker.app<td>True<td>com.attacker.app<td>True confirmed<td>*3
</table>

<ol>
	<li> If the declaration of the origin was from a web application running in a legitimate browser, the netstat should have found the name of the browser that is registered in the white-list of legitimate browsers, instead of the package name of the attacking native application, com.attacker.app.
	<li>The package name that the netstat has found is different from the origin that the application is declaring in the HTTP header.
	<li>GotAPI Auth Server confirms what the native application is declaring in the HTTP header is authentic.
</ol>

<p>The figure below shows the procedure of application authorization on the GotAPI-2 Interface including the security enforced measures against the threats, GotAPI Auth Server spoofing, and application origin spoofing.</p>

<p>In order to prevent GotAPI Auth Server spoofing and application’s origin spoofing, the GotAPI Auth Server SHOULD be able to support the security enforced GotAPI-2 Interface procedures as described in the figure below.</p>

<figure id="5" style="display: table; width: 100%; text-align: center;">
<figcaption><b>Procedure of security enforced application authorization on the GotAPI-2 Interface</b></figcaption>
<img src="images/security_enforced_application_authorization.png" style="width: 80%; align: center;"/>
</figure>
</section>
</section>

<section id="7.3.2.3">
<h4>GotAPI-3</h4>
<p>The GotAPI-3 interface enables the remote provisioning of API access authorizations through a policy management function, which may include one or more of:</p>
<ul>
	<li>OMA Device Management, using a Managed Object (MO) defined by the GotAPI enabler [OMA DM]</li>
	<li>An implementation-specific policy management service</li>
</ul>

<p>Note: The GotAPI 1.0 does not specify the Managed Object (MO) for the GotAPI enabler.</p>
</section>
	
<section id="7.3.2.4">
<h4>GotAPI-4</h4>
<p>The GotAPI-4 interface enables Extension Plug-Ins for external devices and internal enablers through which they communicate with the GotAPI Server. Note that host-device-internal enablers/applications may also be connected to GotAPI servers directly in implementation specific ways without using the GotAPI-4 interface and Extension Plug-Ins.</p>
<p>The Extension Plug-Ins are independent applications. They are the mediators between the GotAPI Server, and external devices and internal enablers/applications. Typically, there are expected to be multiple Extension Plug-In applications installed on a device by the user or preinstalled on the device. An Extension Plug-In application may be developed:</p>
<ul>
	<li>For a group of devices, e.g., a series of devices from a company, or a single device or an enabler,</li>
	<li>By a developer that is different from the provider of GotAPI or applications that use the devices or enablers through the Extension Plug-In.</li>
</ul>
<p>The GotAPI-4 interface provides the following functions with respect to Extension Plug-Ins:</p>
<ul>
	<li>Plug-In Discovery: GotAPI-4 Plug-In Discovery enables the GotAPI Server to discover the targeted Extension Plug-In which an application wants to access and communicate with.</li>
	<li>Service Discovery: GotAPI-4 Service Discovery enables the GotAPI Server to find all the services provided by an Extension Plug-In. In this context, the "service" means an external device or a function provided by an internal enabler through an Extension Plug-In. The Service Discovery provides not only the list of services but also the availability of each service at the time.</li>
	<li>Approval: GotAPI-4 Approval is the function to ensure security, especially to protect users’ data and privacy from unwanted exploits, so that the users can safely use the application with external devices and enablers that are connected via Extension Plug-Ins.</li>
	<li>Data Forwarding: GotAPI-4 Data Forwarding is the function that enables an application to communicate with the targeted Extension Plug-In through the GotAPI Server. Data Forwarding takes place after Plug-In Discovery (optional) and Approval processes have been successfully completed. GotAPI-4 Data Forwarding uses the “pass-through” mechanism, so that the application can access and communicate with the APIs that (i) are implemented in the Extension Plug-In and (ii) expose the features of the external devices or internal enablers.</li>
  </ul>
<p>Note that the APIs to be implemented in Extension Plug-Ins that expose features of external devices and internal enablers are out of the scope of this specification.</p>
	
<section id="7.3.2.4.1">
<h5>Plug-In Discovery</h5>
<p>When applications use Extension Plug-Ins through the GotAPI Server, the GotAPI Server has to know what Extension Plug-Ins are installed. This section describes how the GotAPI Server discovers the installed Extension Plug-Ins in the local devices. </p>
<p>Therefore:</p>
<ul>
	<li>The GotAPI SHALL support the Plug-In Discovery if GotAPI-4 is supported.</li>
	<li>The GotAPI Server SHALL support a mechanism to know what Plug-Ins are installed in the local device.</li>
</ul>
<p>To discover the installed Extension Plug-Ins, the GotAPI Server has to use OS-specific mechanisms and functions. Regarding Android, see the section "Appendix F. Finding the installed Plug-Ins for Android".  </p>
<p>Note: how the GotAPI Server discovers Extension Plug-Ins is out of the scope of this specification.</p>
<p>How to ensure that Extension Plug-Ins on an OS from different vendors are able to be discovered by a GotAPI Server implementation is the responsibility of the provider of the GotAPI Server implementation.</p>
</section>
	
<section id="7.3.2.4.2">
<h5>Service Discovery</h5>
<p>In many cases, one Extension Plug-In is associated with one external device. Some Extension Plug-Ins are associated with multiple external devices. Some Extension Plug-Ins provide functions that work in the local device but is not associated with any external device (a.k.a. an internal enabler itself). Such external devices or functions are called "services".</p>
<p>When an application wants to use a service, it needs to specify the identifier of the service rather than the Extension Plug-In that is supporting the service. Applications basically don't care about what Extension Plug-In is associated with the service.</p>
<p>The Service Discovery enables applications to find services. Some applications, however, may be pre-programmed with specific services. Others may want to find what services are available.</p>
<p>Therefore:</p>
<ul>
	<li>The use of the Service Discovery is OPTIONAL for applications wishing to use services.</li>
	<li>The GotAPI SHALL support the Service Discovery if the GotAPI-4 is supported.</li>
	<li>The GotAPI-1 SHALL support the Requests and Responses for the Service Discovery if GotAPI-4 is supported. This is to ensure consistent interface for application developers.</li>
	<li>GotAPI-4 SHALL support the protocol (the data container format) between the GotAPI Server and the Extension Plug-Ins. This is to ensure consistent interface for Extension Plug-In developers.</li>
</ul>
<p style="text-decoration: underline;">Example of Service Discovery</p>
<p>The following example is based on an implementation on Android.</p>

<figure id="6" style="display: table; width: 100%; text-align: center;">
<figcaption><b>Service Discovery Procedure</b></figcaption>
<img src="images/Service_Discovery.png" style="width: 80%; align: center;"/>
</figure>

<p>Terminology:</p>
<ul>
	<li><b>Explicit Intents</b> are Intents with a specific application identifier, enabling the sending application to specify the exact receiving application to be run. </li>
</ul>
<p style="text-decoration: underline;">Description of operation:</p>
<p><b>General operation:</b>
<ol>
	<li>the GotAPI Server has received a Service Discovery request from an application over the GotAPI-1 interface, the GotAPI Server sends a Service Discovery Command to each of the installed Extension Plug-Ins using the protocol (the data container format) of GotAPI-4 over an Explicit Intent. Note: The Plug-In Discovery has already found Extension Plug-Ins that are installed on the device.</li>
	<li>an Extension Plug-In receives a Service Discovery Command from the GotAPI Server, the Extension Plug-In checks the availability of the service that is requested by the Service Discovery. When the Extension Plug-In completes checking the availability of the service, the Extension Plug-In sends a response to the GotAPI Server over an Explicit Intent.</li>
	<li>the GotAPI Server has received responses from all of the Extension Plug-Ins, the GotAPI Server returns the result to the application as one response.</li>
</ol></p>
<p><b>Multiple plug-ins and asynchronous responses:</b></p>
<p>Since there can be multiple Extension Plug-Ins installed on the device, each response is sent to the GotAPI Server asynchronously. </p>

<p><b>White List:</b></p>
<p>When an Extension Plug-In sends a response, it uses an Explicit Intent to the pre-defined GotAPI Server that is listed in the White List. The White List is provided in each Extension Plug-In by the provider of the Extension Plug-In. The White List enables Extension Plug-Ins to send responses only to the GotAPI Server applications that are listed in the list and prevents Extension Plug-Ins from sending responses to unknown GotAPI Servers. This is to disable spoofed GotAPI Servers to use Extension Plug-Ins.</p>

<p><b>Consolidated response from GotAPI Server:</b></p>
<p>After consolidating the responses that are sent from multiple Extension Plug-Ins asynchronously, the GotAPI Server sends a response to the originating application with the information that are received from the Extension Plug-Ins.</p>

<p><b>Stateless:</b></p>
<p>The GotAPI Server itself does not keep the status of the services that are discovered by the Service Discovery Command, keeping GotAPI Server stateless in terms of services. It is the sole responsibility of the applications that have received the service status information how to keep or use it.</p>

<p>Note: As described in the Plug-In Discovery section, the GotAPI Server must keep the up-to-date status of the Extension Plug-Ins that are installed on the device.</p>
</section>
	
<section id="7.3.2.4.3">
<h5>Approval</h5>
<p>After an application is registered by the GotAPI Authentication Server through user permission, the application is eligible for accessing Services provided by Plug-Ins. To ensure protecting user’s data and privacy, however, before the user is able to access the Services via the Plug-In using the application, the user shall be able to authorize the application to access the Plug-In and the Service. To enable this requirement</p>
<ul>
	<li>The application SHOULD be authorized to access the Plug-In and the device by the user.</li>
	<li>The GotAPI-1 SHALL support the Requests and Responses for authorization to access an application to a Plug-In via user authorization. This is to ensure consistent interface for application developers.</li>
	<li>The GotAPI-1 SHALL support the Requests and Responses for authorization to access an application to a Plug-In via user authorization if GotAPI-4 is supported</li>
  </ul>

<p>The authorization mechanism for Services and Plug-Ins over the GotAPI-4, based on an implementation on Android consists of the following steps:
<ol>
	<li><b>Plug-In Service API Access Request</b>: Typically after the application performing Service Discovery to get the information of the available Services via installed Plug-Ins, the application requests a Plug-In Service API Access Request to the GotAPI Server over the GotAPI-1 interface.
	<li><b>Application Registration to Plug-Ins</b>: If the request is made for the first time, the GotAPI Server requests Application Registration to the targeted Plug-In over the GotAPI-4 with the origin of the application. Then the Plug-In registers the application and creates a clientId which is an identifier of the application managed by the Plug-In. 
	<li><b>idClientId and White List</b>: The Plug-In returns the clientId to the GotAPI Server over the GotAPI-4 interface, using an Explicit Intent. The Explicit Intent with the White List in the Plug-In disables providing a clientId to a spoofed GotAPI Server (the same mechanism as in the Plug-In Discovery).
	<li><b>Access Token and User Authorization</b>: The GotAPI Server requests an access token with the clientId and the serviceId provided by the application over the GotAPI-1 Interface. Upon receiving the access token request, the Plug-In pops up a dialog box to the user, which prompts the user to select the permission for the Service provided by the Plug-In. If the user permits the access request, the Plug-In creates an access token and returns it to the GotAPI Server. Note that an access token is used only between the GotAPI Server and Plug-Ins over the GotAPI-4 interface.
	<li><b>Accessing API using access token</b>: When the GotAPI Server receives the access token from the Plug-In, the GotAPI Server passes the Plug-In Service API Access Request from the application to the Plug-In over GotAPI-4 with the access token. When the GotAPI Server receives the response form the Plug-In, the GotAPI Server passes the response from the Plug-In to the application over the GotAPI-1 interface.
	<li><b>Reusable access token and life time</b>: Once the GotAPI Server receives an access token for an application, the GotAPI Server doesn't need to request another Application Registration or an access token as long as the requested Service is the same. The GotAPI Server can continue using the same access token for a while as long as the Plug-In accepts the access token. An access tokens is given a life time, so that the same access token can be used before the life time is expires. After the life time is expired, the GotAPI Server must request another access token using the same procedure. 
</ol></p>

<figure id="6" style="display: table; width: 100%; text-align: center;">
<figcaption><b>Service and Plug-In Approval</b></figcaption>
<img src="images/Service_and_Plug-In_Approval.png" style="width: 80%; align: center;"/>
</figure>

<p>The parameters (e.g. profile, attribute, etc.) in the diagram above are simplified examples. See the section "8.1 GotAPI Server" for the exact definition of the data set.</p>
</section>

<section id="7.3.2.4.4">
<h5>Data Forwarding</h5>
<p>Once a connection between the GotAPI Server and the targeted Extension Plug-In is established (i.e., GotAPI-4 Plug-In Discovery (optional) and GotAPI-4 Approval have been successfully completed), the application can communicate with the targeted Extension Plug-In. The data transferred between the application and the Extension Plug-In pass-through the GotAPI Server.</p>
<p>The GotAPI-4 Data Forwarding defines the protocol (the data container format) between the GotAPI Server and the Extension Plug-Ins that are connected with external devices or internal enablers.</p>
<p>Example:</p>
<p>The following description and Figure-4 show how the pass-through mechanism of the Data Forwarding works:</p>
<p>An application sends a request to the GotAPI Server using an HTTP connection with some parameters in accordance with the GotAPI-1. The GotAPI Server converts the request to the data format (protocol) in accordance with the GotAPI-4 Data Forwarding specification. Then the GotAPI Server conveys the converted data to the targeted Extension Plug-in using the OS adaptation, such as Intent for Android.  Finally, the Extension Plug-In invokes the APIs with the received and re-converted data. The APIs are implemented in the Extension Plug-In. This mechanism allows requests and responses between applications and external or internal entities to be passed-through to the APIs.</p>
	
<figure id="7" style="display: table; width: 100%; text-align: center;">
<figcaption><b>Pass-through mechanism of Data Forwarding</b></figcaption>
<img src="images/Pass-through_mechanism_of_Data_Forwarding.png" style="width: 80%; align: center;"/>
</figure>

<p>The JSON data and some URIs in the diagram above are just samples and simplified. See the section "8.1 GotAPI Server" for the exact definition of the data set.</p>

<p>In order to get data (binary files, streaming, event notifications, etc.) using HTTP or a different protocol, e.g., WebSocket, Server-Sent Events , WebRTC, from the Plug-Ins, the Temporary Server Feed (TSF) mechanism may be used:</p>
<ul>
	<li>An application sends a request to the GotAPI Server over the GotAPI-1 interface. </li>
	<li>The GotAPI Server passes the request to the Plug-In over the GotAPI-4 interface. </li>
	<li>When the Plug-In receives the request, the Plug-In creates a non-predictable random URI for the binary data that is requested, and associates the URI with the data. </li>
	<li>The Plug-In sends a response with the URI and additional information (if needed) to the GotAPI Server over the GotAPI-4 interface, and the GotAPI Server passes the response to the application over the GotAPI-1 interface.</li>
	<li>Receiving the URI, the application accesses the URI using the protocol that is indicated by the Plug-In in order to get the requested data from the Plug-In directly. The Plug-In works as a Web server.</li>
	<li>The Plug-In discards the URI after the application gets the binary data or a preset life time expires for the purpose of security.</li>
	<li>The URI may use the same IP address as the GotAPI Server but with a different port number. This enables the Plug-In to be a separate application than the GotAPI Server application.</li>
</ul>
	
<figure id="8" style="display: table; width: 100%; text-align: center;">
<figcaption><b>The TSF mechanism for GotAPI-4</b></figcaption>
<img src="images/The_TSF_mechanism_for_GotAPI-4.png" style="width: 80%; align: center;"/>
</figure>

<p>The JSON in the diagram above are simplified examples. See the section "8.3 GotAPI Server" for the exact definition of the data.</p>
<p>The example in the figure below shows how the Plug-in can use WebSocket for the TSF mechanism. WebSocket allows the Plug-in to push asynchronous real-time event notifications fired by the external device to the application, and to accept commands from the application.</p>

<figure id="9" style="display: table; width: 100%; text-align: center;">
<figcaption><b>WebSocket used for the TSF</b></figcaption>
<img src="images/WebSocket_used_for_the_TSF.png" style="width: 80%; align: center;"/>
</figure>

</section>
</section>
</section>
</section>

<section id="7.4">
<h2>Security Considerations</h2>

<section id="7.4.1">
<h3>Authorization</h3>
<p>GotAPI may be used to expose APIs which provide access to sensitive device functions or data. This presents a risk of exposure of device functions and data without informing the user or obtaining consent, or from rogue applications that seek to fraudulently access GotAPI based APIs. Note that whether a specific GotAPI based API is considered to expose sensitive functions or data must be clarified by the specification for the GotAPI based API. The following requirements are intended to address the general risk of unauthorized access to GotAPI based APIs:</p>
<ul>
	<li>If sensitive functions or data are exposed by a GotAPI based API, the GotAPI Server  SHALL verify API access permission for the specific application, before providing API service.</li>
	<li>GotAPI Servers SHALL provide at least one means of managing API access permissions, including one or more of:</li>
    <ul>
  	<li>Permissions that are remotely managed via OMA Device Management [OMA DM] using the GotAPI Permissions managed object [GotAPI MO]</li>
  	<li>Permissions that are remotely managed via implementation-specific means</li>
  	<li>Permissions that are managed by the user through GotAPI Authorization Server user interfaces</li>
    </ul>
</ul>
<p>GotAPI Servers SHALL support access permissions granted on a variety of bases, including:</p>
<ul>
	<li>Free access, i.e. no permission required</li>
	<li>Global access, meaning that once access is granted to any device or application, all further requests are allowed</li>
	<li>Device-specific access, meaning that access is authorized on a per-device basis, including local device access, subnet-based access (e.g. to enable access by any device in a private network), or specific devices by source IP address</li>
	<li>Application-specific access, meaning that access is authorized for each application which can be reliably identified using:</li>
    <ul>
  	<li>For web-based applications, the HTTP Origin header</li>
  	<li>For native applications and Hybrid Native/Web Apps, an application identifier as specific to the native platform</li>
    </ul>
</ul>
</section>

<section id="7.4.2">
<h3>Confidentialty and Integrity </h3>
<p>GotAPI is intended to support securely-exposed APIs to help ensure confidentiality and integrity of API operations when needed. When protected by transport layer security (e.g. TLS 1.2), GotAPI based APIs require consideration of the following potential issues:</p>
<ul>
	<li>GotAPI Servers are unlikely to be provisionable with server certificates that can be validated by clients. For APIs exposed over TLS, this will likely result at least in certificate warnings at the client, and possibly failure of the client to connect to the GotAPI Server.</li>
</ul>
<p>Other means of ensuring confidentiality and integrity of API operations may also be supported, such as API request/response payload encryption based upon pre-shared or dynamically established encryption keys. </p>

<section id="5.4.2.1">
<h4>Confidentiality</h4>
<p>Depending on the underlying platforms or UAs, there are cases where confidentiality protection is already granted. For such cases, there is no need to support this requirement. If, however, the underlying mechanisms do not support data confidentiality protection, this requirement should be supported. To support message confidentiality (1) transport encryption, e.g., TLS/SSL, or (2) end-to-end encryption are available. But transport encryption e.g., TLS/SSL, has some issues applying to the GotAPI environments. For end-to-end encryption, the encryption keys may be distributed through the Trusted Channel as defined in section 7.4.3.3.</p>
</section>

<section id="5.4.2.2">
<h4>Integrity</h4>
<p>Depending on the underlying platforms or UAs, there are cases where integrity protection is already granted. For such cases, there is no need to support integrity requirement by the GotAPI enabler. If, however, the underlying mechanisms do not support integrity protection, this requirement should be supported.</p>
<p>In case where message integrity check is needed depending on the OS, the UA or the environment, HMAC message authentication can be used. The HMAC server authentication that is defined in 7.3.3 is optimized only for server authentication, not including message authentication. In order to apply HMAC for message integrity check as well as server authentication, an HMAC needs (i) to incorporate both the message and the nonce, and (ii) to be generated, sent and verified in both ways symmetrically.</p>
</section>
</section>

<section id="7.4.3">
<h3>Immunity from Attack</h3>
	
<section id="7.4.3.1">
<h4>Traffic based attack </h4>
<p>Since it exposes a service on host devices, the GotAPI enabler by nature consumes device resources in handling service requests. This presents a risk if the GotAPI Server and the GotAPI Auth Server  are not adequately protected from rogue applications that may launch intrusion or denial-of-service (DOS) attacks on the host device, which may cause GotAPI host device instability, unusability, or excessive resource consumption (e.g. battery). Such attacks can involve excessive API requests or malformed API requests. The following requirements are intended to address these risks:</p>
<ul>
	<li>GotAPI Servers and GotAPI Auth Servers SHALL limit API request volume to an unspecified maximum rate, in order to limit exposure to DOS attacks. GotAPI Servers and GotAPI Auth Servers SHALL temporarily disable API permissions for applications that are suspected of excessive API requests.</li>
	<li>GotAPI Servers and GotAPI Auth Servers SHALL ensure the validity of API requests prior to processing them. GotAPI Servers and GotAPI Auth Servers SHALL temporarily disable API permissions for applications that are suspected of sending maliciously malformed API requests.</li>
</ul>
<p>GotAPI Servers and GotAPI Auth Servers SHALL provide a means for users to be informed of applications that have been suspended from API access due to suspected security violations, and a means to re-authorize API access for those applications.</p>
</section>

<section id="7.4.3.2">
<h4>GotAPI Server spoofing attack</h4>
<p>If the underling operating system allows for an application to kill other applications that are running in the background , it is possible for a bogus application to spoof the genuine GotAPI Server or GotAPI Auth Server, and provide fake or harmful information to the application. An attack can be made by 1) terminating the running GotAPI Server and 2) taking over the port that the Server been listening to. If this attack is made, the application that is communicating only through the port, has no way to know that the Server is spoofed. This type of attack is called the server spoofing attack. To prevent this attack, applications must be able to authenticate the Server that they are communicating with.</p>
<p>There are two approaches possible to enable such authentication of the genuine Server.</p>
<ol>
	<li>not to embed any credentials in the GotAPI application, and</li>
	<li>to embed credentials in the GotAPI application</li>
</ol>
<p>The first approach is based on the trust that may be provided by the operating system and/or the application market ecosystem. Many application market ecosystems provide an Application ID for an application that is guaranteed to be unique in the ecosystem including the operating system and the devices. An Application ID may be used for the trust of the GotAPI application for the authenticity. This approach, however, may be a solution depending on the operating system.</p>
<p>The second approach is based on the credential embedded in the application as the trust. It typically requires an external server to verify the authenticity of the credential of the Server for the application. The challenge of this approach is how to protect the credential that is embedded in GotAPI applications from attackers who are able to reverse engineer the applications. If the same credential is embedded in all the application packages and distributed to many devices and if the credential is compromised on one of the devices, all the devices implementing the application would be compromised.</p>
</section>

<section id="7.3.3.3">
<h4>HMAC server authentication using trusted Application ID for the GotAPI Server spoofing attack</h4>
<p>This counter measure works for a platform and a UA that satisfy the following requirements. This is based on the trust provided by the Application ID of the native application, and not embedding any credentials in the GotAPI native application.</p>
<ul>
	<li>The Application ID is unique and trusted, which is guaranteed by the platform.</li>
	<li>The execution environment, e.g., UA, provides a one-way channel for an application to connect directly and send messages to a native application by designating its Application ID, e.g. a URI scheme. </li>
	<li>The application can be connected exclusively and securely with a native application by designating its Application ID. Namely, there is no eavesdropping, no man-in-the-middle, or no spoofed destination in the channel from the application to the destination native application.</li>
</ul>
<p>We call this type of channel as “Trusted Channel”.</p>
<p>Note: <em>Intent URI Scheme</em> for qualified browsers on Android and Explicit intents for Android native application satisfy all these requirements. The destination is designated by the package name of the native application to which applications attempts to send messages</p>
<p>Other assumptions are:</p>
<ul>
	<li>The HTTP channel may be eavesdropped (*).</li>
	<li>Any application can terminate other applications that are running in the background and take over the port that the application is listening to.</li>
	<li>The application knows the Application ID of the genuine GotAPI application, implementing both the GotAPI Server and the GotAPI Auth Server. The Application ID is provided to the application out of the band in a trusted manner.</li>
</ul>
<p>Note: It has been shown that eavesdropping is not possible over the GotAPI-1 or the GotAPI-2 HTTP interfaces on Android unless the device is rooted. Nonetheless, this assumption is introduced here because there may be a way for eavesdropping the HTTP connection that we are not aware of.</p>
<p>If the Trusted Channel is available, the GotAPI Server spoofing attack is prevented using the HMAC server authentication as follows:</p>
<p>Shared key distribution using the Trusted Channel:</p>
<ol>
	<li>The application generates a key, K, composed of unpredictable random characters, and stores the key securely.</li>
	<li>The application sends the key, K, to the genuine rServer through the Trusted Channel designating the Application ID of the genuine GotAPI application. The application knows the genuine GotAPI application’s Application ID in an out-of-band trusted channel.</li>
	<li>The genuine GotAPI application stores the key securely.</li>
</ol>
<p>HMAC calculation and sending messages through the GotAPI-1 or the GotAPI-2 Interface:</p>
<ol>
	<li>Before the application sends a request, it creates a nonce, N, which is a series of random digits that is long enough not to be predicted, and, then, it sends the message, M, and the nonce, N, through the GotAPI-1 or the GotAPI-2 Interface.</li>
	<li>When the genuine GotAPI Server receives the request, it calculates an HMAC, h'=HMAC(K,N), with the nonce, N, and the key, K, that the application distributed through the Trusted Channel before.</li>
	<li>The genuine Server sends a response with the HMAC, h', and the response message, m, to the application through the GotAPI-1 or the GotAPI-2 interface</li>
	<li>The application calculates an HMAC, H'=HMAC(K, N), and  it checks if H' is equal to h' that is received from the GotAPI Server. If equal, verification of the Server authentication is successful and the application verifies that the response has surely been sent by the genuine Server. If not, application determines that the Server that sent the message is spoofed.</li>
</ol>
<p>The figure below presents a normal case of the HMAC server authentication  for the GotAPI Server (the GotAPI Auth Sever case is the same) for a web application.</p>

<figure id="9" style="display: table; width: 100%; text-align: center;">
<figcaption><b>HMAC server authentication – Normal Case</b></figcaption>
<img src="images/HMAC_server_authentication_Normal_Case.png" style="width: 80%; align: center;"/>
</figure>

<p style="text-align: center;">(a web application communicating with the GotAPI Server over GotAPI-1)</p>

<p>The figure below presents a spoofing attack case of the HMAC server authentication, where a web application is communicating with the GotAPI Server over GotAPI-1. The same flows apply to the case of a web application is communicating with the GotAPI Auth Server.</p>
<p>When a bogus server attempts to spoof the genuine GotAPI Server, the bogus server can't calculate a right HMAC because it never knows the key, K, generated by the application.</p>
		
<figure id="9" style="display: table; width: 100%; text-align: center;">
<figcaption><b>HMAC server authentication – Spoofing Attack Case</b></figcaption>
<img src="images/HMAC_server_authentication_Spoofing_Attack_Case.png" style="width: 80%; align: center;"/>
</figure>
	
<p>Since GotAPI Server spoofing is an easy-to-do attack, the GotAPI enabler needs to protect it from the attack.
<ul>
	<li>If the Trusted Channel is available in the device from the application to the genuine Servers, the GotAPI Server and the GotAPI Auth Server SHOULD support the HMAC server authentication described in this section to prevent the Server spoofing attack.</li>
	<li>If the HMAC server authentication is supported, the GotAPI Server and the GotAPI Auth Server SHALL support SHA-256 for the hash algorithm to calculate an HMAC.</li>
	<li>The GotAPI Server and the GotAPI Auth Server SHALL be able to support and respond to the application regardless of the application being using the HMAC server authentication or not. But the GotAPI Server SHALL NOT respond to applications which have not been authenticated by the GotAPI Auth Server through the GotAPI-2 Interface.</li>
	<li>The GotAPI Server and the GotAPI Auth Server SHALL accept keys sent by applications anytime through the Trusted Channel. The GotAPI Server and the GotAPI Auth Server SHALL calculate an HMAC using the new key that was most recently provided from the application.</li>
</ul></p>
</section>
</section>
</section>
</section>

<section id="8">
<h1>Technical Specifications</h1>

<section id="8.1">
<h2>Common APIs for GotAPI applications</h2>

<p>In practice, a GotAPI Server and a GotAPI Auth Server are implemented as a single application which is called as a "GotAPI application".</p>
<p>Applications (web applications running on web browsers or OS-specific native applications) have to check if the GotAPI application is alive, then applications have to invoke the GotAPI application if these servers are not running (i.e. if the GotAPI application is not running).</p>
<p>This section defines the Availability API and the way to invoke GotAPI applications.</p>

<section id="8.1.1">
<h3>Availability API on the GotAPI-1 Interface</h3>
<p>This API provides the status whether the GotAPI application, consisting of the GotAPI Server and the GotAPI Auth Server, is running or not. The application s (web applications running on web browserss or OS-specific native applications) use this API before the application authorization on the GotAPI-2 Interface. The GotAPI Server and the GotAPI Auth Server SHALL accept and respond to the requests for this API coming from any application even if the application authorization on the GotAPI-2 Interface has not been completed.</p>
<table class="oma2">
<caption>Definition of the request</caption>
<col style="width: 20%"/><col style="width: 80%"/>
	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td>Method</td>
		<td>HTTP GET (REST)</td>
	</tr>
	<tr>
		<td>Request URL</td>
		<td>http://127.0.0.1:4035/gotapi/availability<br/>
			https://127.0.0.1:4036/gotapi/availability</td>
	</tr>
	<tr>
		<td>Parameters</td>
		<td>none</td>
	</tr>
</table>

<p>If the GotAPI application is running, the GotAPI Server and the GotAPI Auth Server SHALL respond as follows:</p>

<table class="oma2">
<caption>Definition of the response</caption>
<col style="width: 20%"/><col style="width: 80%"/>
	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td>MIME-Type</td>
		<td>application/json</td>
	</tr>
	<tr>
		<td>HTTP status</td>
		<td>200 OK</td>
	</tr>
</table>

<table class="oma2">
<caption>Example of the response</caption>
	<tr><td><pre class="code">
	{
    "result":0
	}</pre>
</table>

<p>The GotAPI Server and the GotAPI Auth Server SHALL NOT add any extra information in the response for the purpose of protecting the user's privacy from fingerprinting [RFC6973].</p>
</section>

<section>
<h3>Invoking the GotAPI application</h3>

<p>If the application finds that the GotAPI application is not running, it has to invoke the GotAPI application. To do so, the application needs to use an OS-specific or a UA-specific method that enables the application to invoke the GotAPI application.</p>

<p>For example, most of the Android browsers support URI Schemes to invoke a native application with its package name for the web application running on the web browser. If the web application shows a hyper-link embedding the URI scheme, the user can invoke the GotAPI application by tapping it.</p>

<table class="oma2"></p> 
<caption>Example of the URI Scheme with a package name (Android Chrome)</caption>
	<tr><td><pre class="code">
	&lt;a href="intent://#Intent;scheme=gotapi;package=com.example.gotapi;S.origin=app.example.jp;S.key=0123456789;;end"&gt;Invoke the GotAPI Server&lt;/a&gt;</pre>
</table>

<p>In the implementation model that GotAPI 1.0 supports, the GotAPI Server and GotAPI Auth Server are implemented as a single application. Therefore, when the GotAPI application is invoked, both the GotAPI Server and the GotAPI Auth Server are invoked, so that the application can use the GotAPI-1 and GotAPI-2 interfaces.</p>

<p>If the application is an Android native application, it can use an Explicit Intent for invoking the GotAPI application and sending the necessary information.</p>
<ul>
	<li>MAC server authentication used: 
		<p>In order to support the HMAC server authentication as defined in 7.4.3.2.1, the application is expected to provide the GotAPI application with the following data using the OS-specific or the UA-specific method when invoking the GotAPI application as shown in the example above;
			<dl><strong>origin</strong>
			<dd>The origin is an identifier of the application. If the application is a web application, this value is the part of the URL specified as "origin" in RFC6454 (e.g. http://app.example.com). If the application is an OS-specific native application or Hybrid Native/Web App, the application ID recognized by the OS, such as a package name. (e.g. com.example.app).</dd>
			<dl><strong>key</strong>
			<dd>The key is generated by the application, composed of unpredictable random characters. The key is used for HMAC server authentication for the purpose of preventing GotAPI Server spoofing.</dd></p>
		<p>When using the HMAC server authentication, it must be ensured that the OS-specific or the UA-specific method to invoke the GotAPI application must qualify as a Trusted Channel as defined in section 7.3.3.3.</p>
		<p>When the GotAPI application is started by an application, the GotAPI Server SHALL securely store the origin and key provided by the application.</p>
		<p>The GotAPI and the GotAPI Auth Server SHALL retain and associate the origin and key for use in validating subsequent requests from the application.</p>
		<p>The GotAPI and the GotAPI Auth Server MAY set an expiration date/time to the pair of the origin and the key, and MAY revoke the pair when the expiration is reached.</p>
		<p>GotAPI and the GotAPI Auth Server SHALL allow applications to update their key at any time, and any number of times.</p>
	<li>HMAC server authentication not used:
		<p>The application may decide whether or not to use the HMAC server authentication. Hence, the application is not mandated to send the origin and the key in the URI Scheme.</p>
		<p>If the GotAPI application does not receive the key or receives an empty string as the key from the application, the GotAPI Server and the GotAPI Auth Server SHALL recognize that the application is not using the HMAC server authentication and act accordingly.</p>
		<p>GotAPI Servers and the GotAPI Auth Server SHALL support the ability of applications to start using HMAC server authentication at any time.</p>
</ol>

<table class="oma2"></p> 
<caption>Recommendations for applications (non-normative)</caption>
<tbody>
	<tr><td>
	<ul>                 
		<li>The application MAY decide whether or not to use the HMAC server authentication.                                  
		<li>The application MAY update the key at any time, as many times as it likes.                                  
		<li>The application SHOULD update the key whenever the application starts to run, and start the session with a new key.
	</ul>
</tbody>
</table>
</section>
</section>

<section>
<h2>GotAPI Authorization Server</h2>

<p>This section defines the data format used over the GotAPI-2 Interface.</p>

<p>As described in the section "7.3.2.2 GotAPI-2", the application has to obtain authorization for accessing the GotAPI-based APIs from the GotAPI Auth Server over the GotAPI-2 Interface. The GotAPI-2 interface is based upon the concepts of OAuth. The request and response are sent over the HTTP protocol.</p>

<p>Firstly, the application sends an application authorization request with the origin of the application, an identifier of the application, to the GotAPI Auth Server. If the application is a Web Application, the origin is provided in the HTTP Origin request header by the browser as described in [CORS]. If the application is an OS-specific native application or a Hybrid Native/Web App, the origin is an application identifier managed by the underlying OS, such as a package name. For example, if the OS is Android, the origin could be "com.example.app". It has to be set as the value of the HTTP X-GotAPI-Origin request header by the application..</p>

<p>When the GotAPI Auth Server receives the request, the GotAPI Auth Server may check if the origin is acceptable or not. If the origin is acceptable, the GotAPI Auth Server creates a series of random digits, called as a "grant", that is long enough not to be predicted. Then the GotAPI Auth Server returns the grant to the application. This transaction is defined in section "8.7.2 Grant".</p>

<p>Secondary, the application sends an access token request with (i) the origin, which is provided by the browser as described above, (ii) the grant, which was obtained in the previous transaction, and (iii) the scope, which is a collection of the functions that the application wants to use.</p>

<p>When the GotAPI Auth Server receives the request, the GotAPI Auth Server asks the user if the application may use the requested scope shown in the dialog box. If the request is acceptable, the GotAPI Auth Server creates a series of random digits, called as an "access token", that is long enough not to be predicted. This transaction is defined in the section "8.7.3 Access token".</p>

<section>
<h3>Grant</h3>

<p>The application sends an application authorization request as below. The GotAPI Auth Server SHALL be able to receive and process the request that is sent by the application appropriately.</p>

<table class="oma2"> 
<caption>Definition of the request</caption>
	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td>Method
		<td>HTTP GET (REST)
	</tr> 
	<tr>
		<td>Request URL
		<td>http://127.0.0.1:4035/gotapi/authorization/grant<br/>
		https://127.0.0.1:4036/gotapi/authorization/grant
	</tr> 
	<tr>
		<td>HTTP request Header
		<td>
			<dl>Origin:
			<dd><p>This value is the origin of the web application running on the web browser. For example, it could be "http://app.example.com". The application developers do not need to take care of this because this header is automatically set by the web browser.</p>
			<p>This value is MANDATORY if the application is a web application running on a web browser.</p></dl>
			<dl>X-GotAPI-Origin:
			<dd><p>This value is the origin of the OS-specific native application or the Hybrid Native/Web App. For example, an Android native application could set this header to "com.example.app".</p>
			<p>This value is MANDATORY if the application is an OS-specific native application or a Hybrid Native/Web App.</dd></p>
	<tr>
		<td>Parameters
		<td>None
	</tr>
</table>

<table class="oma2"> 
<caption>Example of the request by a web application running on a web browser</caption>
	<tr><td><pre class="code">
	GET /gotapi/authorization/grant HTTP/1.1
	Host: 127.0.0.1
	Origin: http://app.example.com
	...<em>(Other headers)</em></pre>
</table>

<table class="oma2"> 
<caption>Example of the request by an OS-specific native application or a Hybrid Native/Web App</caption>
	<tr><td><pre class="code">
	GET /gotapi/authorization/grant HTTP/1.1
	Host: 127.0.0.1
	X-GotAPI-Origin: com.example.app
	...<em>(Other headers)</em></pre>
</table>

<p>If the X-GotAPI-Origin header exists in the HTTP request header, the GotAPI Auth Server SHALL assume that the application is an OS-specific native application or a Hybrid Native/Web App and the value is the origin of the application. If both of the X-GotAPI-Origin and the Origin exist in the HTTP request header, the GotAPI Auth Server SHALL take the value of the X-GotAPI-Origin as the origin. If only the Origin header exists in the request header, the GotAPI Server SHALL assume that the application is a web application running on a web browser. If neither the Origin header nor the X-GotAPI-Origin header exists, the GotAPI Server SHALL return the error code as defined by the definition of the JSON format of the response below.</p>

<p>After the GotAPI Auth Server determines if the origin of the application is acceptable or not, it SHALL respond as follows:</p>

<table class="oma2"> 
<caption>Definition of the response</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td></td>
		<td>Definitions
	</tr> 
	<tr>
		<td>MIME-Type
		<td>application/json
	</tr> 
	<tr>
		<td>HTTP status
		<td>200 OK
	</tr>
</table>

<table class="oma2"> 
<caption>Definition of the JSON format of the response</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td><strong>Name</strong>
		<td><strong>Sub name</strong>
		<td><strong>Type</strong>
		<td><strong>Definition of value</strong>
		<td><strong>Mandatory/Optional</strong>
	</tr> 
	<tr>
		<td><strong>result</strong>
		<td></td>
		<td>Number
		<td>If the origin was accepted by the GotAPI Auth Server, the value is 0, otherwise an integer other than 0, which indicates an error code.</p>
<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>clientId</strong>
		<td></td>
		<td>String
		<td>The grant which the GotAPI Auth Server created for the accepted origin.</p>
<p>If the origin was not accepted, this value must be an empty string.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>errorCode</strong>
		<td></td>
		<td>String
		<td>If the origin was not accepted or an error occurred, this value is set to an integer other than 0. Otherwise, this value must be 0.</p>
<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>errorMessage</strong>
		<td></td>
		<td>String
		<td>If the origin was not accepted or an error occurred, this value is set to a human-readable letter string describing the error.</p>
<p>Otherwise, this value must be an empty string.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>hmac</strong>
		<td></td>
		<td>String
		<td>An HMAC generated for the counter measure against the Server spoofing attack described in the section "7.4.3.2.1 HMAC server authentication using trusted Application ID for the Server spoofing attack".
		<td>Mandatory if the application provides a key to the GotAPI Auth Server
	</tr>
</table>

<table class="oma2"></p> 
<caption>Example of the response when the origin was accepted successfully</caption>
	<tr><td><pre class="code">
	{
	"result":0,
	"clientId": "0123456789",
	"errorCode": 0,
	"errorMessage": "" ,
	"hmac": "0123.....xyz"
	}</pre>
</table>

<table class="oma2"></p> 
<caption>Example of the response when the origin was not accepted</caption>
	<tr><td><pre class="code">
	{
	"result":1,
	"clientId": "",
	"errorCode": 1,
	"errorMessage": "The application is not an official application of the Example Service." ,
	"hmac": "0123.....xyz"
	}</pre>
</table>

<p>The GotAPI Auth Server MAY append additional name-value pairs in the JSON data as needed.</p>
</section>

<section>
<h3>Access token</h3>

<p>If the application receives the grant (clientId) from the GotAPI Auth Server, the application sends an access token request as below. The GotAPI Auth Server SHALL be able to receive and process the request that is sent by the application appropriately.</p>

<table class="oma2"> 
<caption>Definition of the request</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td></td>
		<td>Definitions
	</tr> 
	<tr>
		<td>Method
		<td>HTTP GET (REST)
	</tr> 
	<tr>
		<td>Request URL
		<td><a href="http://127.0.0.1:4035/gotapi/authorization/accesstoken">http://127.0.0.1:4035/gotapi/authorization/accesstoken</a></p>
<p><a href="https://127.0.0.1:4036/gotapi/authorization/accesstoken">https://127.0.0.1:4036/gotapi/authorization/accesstoken</a>
	</tr> 
	<tr>
		<td>HTTP request Header
		<td>
		<dl>Origin:</dl>
		<dd>This value is the origin of the web application running on the web browser. For example, it could be "http://app.example.com". As this header is automatically set by the web browser, the developer of the application does not need to take care of it.<p>This value is MANDATORY if the application is a web application running on a web browser.</p></dd>
		<dl>X-GotAPI-Origin:</dl>
		<dd>This value is the origin of the OS-specific native application or the Hybrid Native/Web App. For example, the origin of an Android native application, it could be "com.example.app".<p>This value is MANDATORY if the application is an OS-specific native application or a Hybrid Native/Web App.</p></dd>
	</tr> 
	<tr>
		<td>Parameters
		<td>
		<dl>clientId:</dl>
		<dd>This value is the grant that the application received from the GotAPI Auth Server previously.</dd>
		<dl>scope:</dl>
		<dd>The list of functions that the application wants to use. This value is a comma-separated string such as "notification,vibration". This value must not include any white-space.<p>This specification doesn't define the names of the functions. The names of the functions are defined by the GotAPI service provider.</p></dd>
		<dl>applicationName:</dl>
		<dd>This value is the name of the application. This parameter is OPTIONAL. This value will be shown to the user when the user is requested for authorization of the application.</dd>
	</tr>
</table>

<table class="oma2"></p> 
<caption>Example of the request by a web application running on a web browser</caption>
	<tr><td><pre class="code">
	GET /gotapi/authorization/accesstoken?clientId=0123456789&amp;scope=notification,vibration&amp; applicationName=Smart%20Watch&amp;20Controller HTTP/1.1
	Host: 127.0.0.1
	Origin: http://app.example.com
	...<em>(Other headers)</em>
	</pre>
</table>

<table class="oma2"></p> 
<caption>Example of the request by an OS-specific native application or a Hybrid Native/Web App</caption>
	<tr><td><pre class="code">
	GET /gotapi/authorization/accesstoken?clientId=0123456789&amp;scope=notification,vibration&amp; applicationName=Smart%20Watch&amp;20Controller HTTP/1.1</p>
	Host: 127.0.0.1
	X-GotAPI-Origin: com.example.app
	...<em>(Other headers)</em>
	</pre>
</table>

<p>If the X-GotAPI-Orign header exists in the HTTP request header, the GotAPI Auth Server SHALL assume that the application is an OS-specific native application or a Hybrid Native/Web App and the value is the origin of the application. If both of the X-GotAPI-Origin and Origin exist in the HTTP request request header, the GotAPI Auth Server SHALL take the value of the X-GotAPI-Origin as the origin. If only Origin header exists in the request header, the GotAPI Server SHALL assume that the application is a web application running on a web browser. If neither the Origin header nor the X-GotAPI-Origin header exists, the GotAPI Server SHALL return the error code as defined by the definition of the JSON format of the response below..</p>

<p>If the origin is accepted as defined in the section "8.7.2 Grant", the GotAPI Auth Server SHALL ask the user if the application may use the requested scope as described in the section "7.3.2.2 GotAPI-2". If the origin is not accepted, the GotAPI Server SHALL send a response immediately without asking the user anything.</p>

<p>The GotAPI Auth Server SHALL respond as follows:</p>

<table class="oma2"> 
<caption>Definition of the response</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td><strong>MIME-Type</strong>
		<td>application/json
	</tr> 
	<tr>
		<td><strong>HTTP status</strong>
		<td>200 OK
	</tr>
</table>

<table class="oma2"> 
<caption>Definition of the JSON format of the response</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	<tr>
		<td><strong>result</strong>
		<td></td>
		<td>Number
		<td>If the requested scope is authorized by the user through the GotAPI Auth Server, the value is 0, otherwise an integer other than 0, which indicates an error code.</p>
<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>accessToken</strong>
		<td></td>
		<td>String
		<td>The access token which the GotAPI Auth Server created for the authorized scope requested by the application.</p>
<p>If the scope were not authorized, this value must be an empty string.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>errorCode</strong>
		<td></td>
		<td>String
		<td>If the requested scope was not authorized or an error occurred, this value is set to an integer other than 0. Otherwise, this value must be 0.</p>
<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>errorMessage</strong>
		<td></td>
		<td>String
		<td>If the requested scope was not authorized or an error occurred, this value is set to a human-readable letter string describing the error.</p>
<p>Otherwise, this value must be an empty string.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>hmac</strong>
		<td></td>
		<td>String
		<td>An HMAC generated for the counter measure against the Server spoofing attack described in the section "7.4.3.2.1 HMAC server authentication using trusted Application ID for the Server spoofing attack".
		<td>Mandatory if the application provides a key to the GotAPI Auth Server
	</tr>
  </tbody>
</table>

<table class="oma2">
<caption>Example of the response when the requested scope was authorized successfully</caption>
	<tr><td><pre class="code">
	{
    "result":0
	"accessToken": "9876543210",
	"errorCode": 0,
	"errorMessage": "" ,
	"hmac": "0123.....xyz"
	}</pre>
</table>

<table class="oma2">
<caption>Example of the response when the requested scope was not authorized</caption>
	<tr><td><pre class="code">
	{
    "result":1
	"accessToken": "",
	"errorCode": 1,
	"errorMessage": "The requested functions are not available." ,
	"hmac": "0123.....xyz"
	}</pre>
</table>

<p>The GotAPI Auth Server MAY append additional name-value pairs in the JSON data as needed.</p>
</section>
</section>

<section>
<h2>GotAPI Server</h2>

<section>
<h3>Dervice Discovery API on the GotAPI-1 Interface</h3>

<p>This API provides the information about what services the GotAPI Server can supply. This API is available only if the application authorization on the GotAPI-2 Interface is completed.</p>

<table class="oma2"> 
<caption>Definition of the request</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td><strong>Method</strong>
		<td>HTTP GET (REST)
	</tr> 
	<tr>
		<td><strong>Request URL</strong>
		<td>http://127.0.0.1:4035/gotapi/servicediscovery</p>
<p>https://127.0.0.1:4036/gotapi/servicediscovery
	</tr> 
	<tr>
		<td><strong>Parameters</strong>
		<td>None
	</tr>
</table>

<table class="oma2"> 
<caption>Definition of the request parameters</caption>
  	<thead>
		<th>Parameter name</th>
		<th>Definition of value</th>
	</thead>
	<tr>
		<td><strong>accessToken</strong>
		<td>The access token obtained from the GotAPI Auth Server through the GotAPI-2 Interface.
	</tr>
  </tbody>
</table>

<table class="oma2">
<caption>Example of the request URL</caption>
	<tr><td><pre class="code">
	http://127.0.0.1:4035/gotapi/servicediscovery?accessToken=0987654321</pre>
</table>

<p>When the GotAPI Server receives the request, it SHALL run the Plug-In Discovery procedure described in the section "7.3.2.4.1 Plug-In Discovery" and the section "8.6.5 Plug-In discovery on the GotAPI-4 Interface".</p>

<p>When the GotAPI Server completes the Plug-In Discovery procedure, it SHALL respond as follows:</p>

<table class="oma2"> 
<caption>Definition of the response</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td><strong>MIME-Type</strong>
		<td>application/json
	</tr> 
	<tr>
		<td><strong>HTTP status</strong>
		<td>200 OK
	</tr>
</table>

<table class="oma2"> 
<caption>Definition of the JSON format of the response</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	<tr>
		<td><strong>result</strong>
		<td></td>
		<td>Number
		<td><p>If success, the value is 0, otherwise an integer other than 0, which indicates an error code.</p>
		<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>product</strong>
		<td></td>
		<td>String
		<td>The name of the GotAPI Server (e.g. "ABConnect")
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>version</strong>
		<td></td>
		<td>String
		<td>The version of the GotAPI Server (e.g. "1.0").
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>services</strong>
		<td></td>
		<td>Array
		<td>The list of the services. If none of services were found, an empty array is returned.
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>serviceId
		<td>String
		<td><p>The service identifier.</p>
		<p>If this service represents the external device which is connected through the relevant Plug-In, this value must be the device identifier (deviceId).
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>name
		<td>String
		<td><p>The name of the service.</p>
		<p>If this service represents the external device which is connected through the relevant Plug-In, this value must be the name of the external device.
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>manufacturer
		<td>String
		<td><p>The manufacturer of the service.</p>
		<p>If this service represents the external device which is connected through the relevant Plug-In, this value must be the manufacturer of the external device. Otherwise, this value must be the Plug-In provider name.
		<td>Optional
	</tr> 
	<tr>
		<td>
		<td>version
		<td>String
		<td><p>The version of the service.</p>
		<p>If this service represents the external device which is connected through the relevant Plug-In, this value must be the version of the external device. Otherwise, this value must be the Plug-In version.
		<td>Optional
	</tr> 
	<tr>
		<td>
		<td>type
		<td>String
		<td><p>The type of the service.</p>
		
		<p>If this service represents the external device which is connected through the relevant Plug-In, this value represents the type of the network used to connect to the external device. The value must be any one of "WiFi", "BLE", "NFC", or "Bluetooth".
		<td>Optional
	</tr> 
	<tr>
		<td>
		<td>online
		<td>Boolean
		<td>If the service is available at the time, this value is true. Otherwise false.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>hmac</strong>
		<td></td>
		<td>String
		<td>An HMAC generated for the counter measure against the GotAPI Server spoofing attack described in the section "7.4.3.2.1 HMAC server authentication using trusted Application ID for the GotAPI Server spoofing attack".
		<td>Mandatory if the application provides a key to the GotAPI Server
	</tr>
</table>

<p>The following example shows that the GotAPI Server has discovered two services. The first one is a service provided by an internal enabler Plug-In, which provides CPU information of the local device. The second one is a service provided by an external device.</p>

<table class="oma2">
<caption>Example of the response</caption>
	<tr><td><pre class="code">
	{
	"result":0,
	"product": "ABConnect",
	"version": "1.0",
	"services":[
	{
	"id":"deviceinfo.plugin1.example.org",
	"name":"Local Device Information Analyzer",
	"manufacturer": "ABC Software Inc.",
	"version": "2.3",
	"type":"cpuInfo",
	"online":true 
	},
	{
	"id":"device1.plug-in2.example.org",
	"name":"Smart watch DC01A",
	"manufacturer": "ABC Electric Inc.",
	"version": "3.0",
	"type":"WiFi",
	"online":true 
	}
	],
	"hmac": "0123.....xyz"
	}</pre>
</table>

<p>The GotAPI Server MAY append additional name-value pairs in the JSON data as needed.</p>
</section>

<section>
<h3>Service Information API on the GotAPI-1 Interface</h3>

<p>This API provides the detailed information of the service provided by internal capabilities of the host device and external devices connected through the relevant Plug-In. This API is available only if the application authorization on the GotAPI-2 Interface is completed.</p>

<table class="oma2"> 
<caption>Definition of the request</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td><strong>Method</strong>
		<td>HTTP GET (REST)
	</tr> 
	<tr>
		<td><strong>Request URL</strong>
		<td><p>http://127.0.0.1:4035/gotapi/serviceinformation</p>
		<p>https://127.0.0.1:4036/gotapi/serviceinformation
	</tr>
</table>

<table class="oma2"> 
<caption>Definition of the request parameters</caption>
  	<thead>
		<th>Parameter name</th>
		<th>Definition of value</th>
	</thead>
	<tr>
		<td><strong>serviceId</strong>
		<td>The identifier of the targeted service. This value is available from the Service Discovery API on the GotAPI-1 Interface.
	</tr> 
	<tr>
		<td><strong>accessToken</strong>
		<td>The access token obtained from the GotAPI Auth Server through the GotAPI-2 Interface.
	</tr>  
</table>

<table class="oma2">
<caption>Example of the request URL</caption>
	<tr><td><pre class="code">
	http://127.0.0.1:4035/gotapi/serviceinformation?serviceId=abcdefg123&amp;accessToken=0987654321</pre>
</table>

<p>When the GotAPI Server receives the request, it SHALL respond as follows:</p>

<table class="oma2"> 
<caption>Definition of the response</caption>
  	<thead>
		<th></th>
		<th>Definitions</th>
	</thead>
	<tr>
		<td><strong>MIME-Type</strong>
		<td>application/json
	</tr> 
	<tr>
		<td><strong>HTTP status</strong>
		<td>200 OK
	</tr>  
</table>

<table class="oma2"> 
<caption>Definition of the JSON format of the response</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	<tr>
		<td><strong>result</strong>
		<td></td>
		<td>Number
		<td><p>If success, the value is 0, otherwise an integer greater than 0, which indicates an error code.</p>
		<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>product</strong>
		<td></td>
		<td>String
		<td>The name of the GotAPI Server (e.g. "ABConnect")
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>version</strong>
		<td></td>
		<td>String
		<td>The version of the GotAPI Server (e.g. "1.0").
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>connect</strong>
		<td></td>
		<td>Object
		<td></td>
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>wifi
		<td>Boolean
		<td><p>If the external device are available through WiFi, the value is true, otherwise false.</p>
		<p>If the external device doesn't support the WiFi connection, this name-value pair must not exist.</p>
		<td>Mandatory if the external device supports the WiFi connection.
	</tr> 
	<tr>
		<td>
		<td>bluetooth
		<td>Boolean
		<td><p>If the external device are available through Bluetooth, the value is true, otherwise false.</p>
		<p>If the external device doesn't support the Bluetooth connection, this name-value pair must not exist.</p>
		<td>Mandatory if the external device supports the Bluetooth connection.
	</tr> 
	<tr>
		<td>
		<td>nfc
		<td>Boolean
		<td><p>If the external device are available through NFC, the value is true, otherwise false.</p>
		<p>If the external device doesn't support the NFC connection, this name-value pair must not exist.</p>
		<td>Mandatory if the external device supports the NFC connection.
	</tr> 
	<tr>
		<td>
		<td>ble
		<td>Boolean
		<td><p>If the external device are available through BLE, the value is true, otherwise false.</p>
		<p>If the external device doesn't support the BLE connection, this name-value pair must not exist.</p>
		<td>Mandatory if the external device supports the BLE connection.
	</tr> 
	<tr>
		<td><strong>supports</strong>
		<td></td>
		<td>Array
		<td><p>The list of the available API names.</p>
		<p>This specification doesn't define the names.</p>
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>hmac</strong>
		<td></td>
		<td>String
		<td><p>An HMAC generated for the counter measure against the GotAPI Server spoofing attack described in the section "7.4.3.2.1 HMAC server authentication using trusted Application ID for the GotAPI Server spoofing attack".
		<td>Mandatory if the application provide a key to the GotAPI Server
	</tr>  
</table>

<table class="oma2">
<caption>Example of the response</caption>
	<tr><td><pre class="code">
	{
	"result":0,
	"product": "ABConnect",
	"version":"1.0",
	"connect":[
	"wifi":true
	],
	"supports":[
	"system",
	"battery",
	"vibration"
	],
	"hmac": "0123.....xyz "
	}</pre>
</table>

<p>The GotAPI Server MAY append additional name-value pairs in the JSON data as needed.</p>
</section>

<section>
<h3>Common data set of responses on the GotAPI-1 Interface</h3>

<p>The GotAPI Server SHALL include the following data in all responses on the GotAPI-1Interface. The data set SHALL not be used for other purposes.</p>

<table class="oma2"> 
<caption>Common data set for the response on the GotAPI-1 Interface</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	<tr>
		<td><strong>product</strong>
		<td></td>
		<td>String
		<td>The name of the GotAPI Server (e.g. "ABConnect")
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>version</strong>
		<td></td>
		<td>String
		<td>The version of the GotAPI Server (e.g. "1.0").
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>hmac</strong>
		<td></td>
		<td>String
		<td>An HMAC generated for the counter measure against the GotAPI Server spoofing attack described in the section "7.4.3.2.1 HMAC server authentication using trusted Application ID for the GotAPI Server spoofing attack".
		<td>Mandatory if the application provide a key to the GotAPI Server
	</tr>
  
</table>
</section>

<section>
<h3>Plug-In discovery on the GotAPI-4 Interface</h3>

<p>When the application requests the Service Discovery described in the section "8.6.3 Service Discovery API on the GotAPI-1 Interface", the GotAPI Server SHALL find the installed Plug-Ins and obtain information from each , and, then, ask the Plug-Ins about what devices it provides access to are available at the time . After all the Plug-Ins have responded, the GotAPI Server SHALL return the results of the Plug-In discovery to the application. See the section "7.3.2.4.1 Plug-In Discovery" for the detailed architecture.</p>

<p>Using the GotAPI-4 Interface, the GotAPI Server sends the data object for the Plug-In discovery request to all the installed Plug-Ins as defined blow:</p>

<table class="oma2"> 
<caption>Definition of the data object for the Plug-In discovery request</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	<tr>
		<td><strong>receiver</strong>
		<td></td>
		<td>String
		<td>The address of the GotAPI Server application used by Plug-Ins. Generally, it is the application ID recognized by the OS.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>requestCode</strong>
		<td></td>
		<td>int
		<td>A request code identifying the request. This value could be any number but must MUST be an integer greater than 0, and unique for each open request, to ensure responses can be correlated.
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>api</strong>
		<td></td>
		<td>String
		<td>The value must be "gotapi".
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>profile</strong>
		<td></td>
		<td>String
		<td>The value must be "networkServiceDiscovery".
		<td>Mandatory
	</tr> 
	<tr>
		<td><strong>attribute</strong>
		<td></td>
		<td>String
		<td>The value must be "getNetworkServices".
		<td>Mandatory
	</tr>
</table>

<p>The GotAPI Server MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>Requirements for OS-specific request channel and data container</caption>
  	<thead>
		<th>OS</th>
		<th>Description</th>
	</thead>
	<tr>
		<td><strong>Android</strong>
		<td>The GotAPI Server must use Explicit Intents for the request.</p>
<p>The data object must be mapped to the Extra directly.
	</tr>  
</table>

<table class="oma2"> 
<caption>Example of the Android Implicit Intent data object</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td><strong>Action</strong>
		<td>
		<td>"org.deviceconnect.action.GET"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td><strong>Component</strong>
		<td>
		<td>"org.example.plugin"
		<td>This value is the package name of the Plug-In application.
	</tr> 
	<tr>
		<td><strong>Extra</strong>
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><strong>receiver</strong>
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server.
	</tr> 
	<tr>
		<td>
		<td><strong>requestCode</strong>
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><strong>api</strong>
		<td>"gotapi"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><strong>profile</strong>
		<td>"serviceDiscovery"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><strong>attribute</strong>
		<td>"services"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>
  
</table>

<p>When the Plug-In receives the Plug-In discovery request from the GotAPI Server, the Plug-In SHALL determine whether the corresponding devices are available at the time, and, then, SHALL send the data object of the Plug-In discovery response to the GotAPI Server as defined below:</p>

<table class="oma2"> 
<caption>Definition of the data object for the Plug-In discovery response</caption>
  	<thead
		<th> Name
		<th> Sub name 
		<th> Type
		<th> Definition of value
		<th> Mandatory/Optional
	</thead>
	<tr>
		<td> requestCode
		<td></td>
		<td>int
		<td>The request code coming from the GotAPI Server.
		<td>Mandatory
	</tr> 
	<tr>
		<td> result
		<td></td>
		<td>int
		<td><p>If success, the value is 0, otherwise an integer other than 0, which indicates an error code.</p>
		<p>This specification doesn't define error codes.</p>
		<td>Mandatory
	</tr> 
	<tr>
		<td> services
		<td></td>
		<td>Array
		<td></td>
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>serviceId
		<td>String
		<td><p>The service identifier representing the external device or internal service. This id must be a string which is the concatenation of the identifier of the Plug-In and the identifier of the device. For example, if the identifier of the Plug-In is "org.example.plugin" and the identifier of the external device is "12345", the id could be "com.example.plugin.12345".</p>
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>name
		<td>String
		<td>The name of the device.
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>manufacturer
		<td>String
		<td><p>The manufacturer of the service.</p>
		<p>If this service represents the external device which is connected through the relevant Plug-In, this value must be the manufacturer of the external device. Otherwise, this value must be the Plug-In provider name.</p>
		<td>Optional
	</tr> 
	<tr>
		<td>
		<td>version
		<td>String
		<td><p>The version of the service.</p>
		<p>If this service represents the external device which is connected through the relevant Plug-In, this value must be the version of the external device. Otherwise, this value must be the Plug-In version.</p>
		<td>Optional
	</tr> 
	<tr>
		<td>
		<td>type
		<td>String
		<td>The type of the network used to connect to the device. The value must be any one of "WiFi", "BLE", "NFC", or "Bluetooth".
		<td>Optional
	</tr> 
	<tr>
		<td>
		<td>online
		<td>Boolean
		<td>True if the device is online and available, False otherwise.
		<td>Mandatory
	</tr> 
	<tr>
		<td>
		<td>scopes
		<td>Array
		<td><p>The list of profiles that the application wants to use. (e.g. ["file", "notification", "vibration"]). A profile is a set of functions supported by the Plug-In.</p>
		<p>This specification doesn't define the profile names. The profile names are defined by Plug-Ins.</p>
		<td>Mandatory
	</tr>
</table>

<p>The Plug-In MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>Requirements for OS-specific response channel and data container</caption>
  	<thead>
		<th> OS
		<th> Description
	</thead>
	<tr>
		<td> Android
		<td>The GotAPI Server must use Explicit Intents for the response.</p>
<p>The data object must be mapped to the Extra directly.
	</tr>  
</table>

<table class="oma2"> 
<caption>Example of the Android Explicit Intent data object</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td> Action
		<td>
		<td>"org.deviceconnect.action.RESPONSE"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td> Component
		<td>
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server application.
	</tr> 
	<tr>
		<td> Extra
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> requestCode
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> result
		<td>0
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> services
		<td><em>[Array Object]</em>
		<td>This value is an example. Note that this is "not" a JSON string. This value must be an Array object whose content is the same as the following JSON example:
		<pre class="code">
[
{
"id": "org.example.plugin.12345",
"name": "Smart Watch S23P",
"manufacturer": "ABC Electric Inc.",
"version": "3.0",
"type": "Bluetooth",
"online": true,
"scopes": [
"notification",
"vibration"
]
},
...
]</pre>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>  
</table>

<p>When the GotAPI Server receives the responses from the Plug-Ins through the Plug-In discovery, it SHALL create a mapping table which associates the service identifier with the relevant Plug-In.</p>

<p>The application doesn't care about what services are associated with what Plug-Ins. When the application sends a request on the GotAPI-1 Interface, it specifies only the service identifier. When the GotAPI Server receives a request with a serviceId on the GotAPI-1 Interface from the application, the GotAPI Server SHALL determine the relevant Plug-In from the mapping table.</p>

<p>As described in the table "Definition of the data object for the Plug-In discovery response", the id of each service (external device or internal service) is a string which is the concatenation of the identifier of the Plug-In and the identifier of the service. That is, the id of the service should be unique in a host device. But every Plug-Ins may not necessarily follow the requirement. If multiple Plug-Ins report a same service id, the in the GotAPI Server SHALL take the first reported service id and the others SHALL be ignored.</p>
</section>

<section>
<h3>Plug-In approval on the GotAPI-4 Interface</h3>

<p>As described in the section "7.3.2.4.2 Approval", when an application requests an API access to a device through the corresponding Plug-In for the first time, the GotAPI Server SHALL obtain a permission for the API accesses from the Plug-In. This procedure is composed of the two steps:</p>

<p>(1) The GotAPI Server requests registration of the application to the Plug-In.</p>

<p>(2) The GotAPI Server requests an access token to the Plug-In</p>

<p>This section defines the data object of the requests and responses for each step.</p>
</section>

<section>
<h4>Request for registration of application</h4>

<p>When an application requests an API access to a device through the corresponding Plug-In for the first time, the GotAPI Server SHALL send an app registration request and get a clientId from the Plug-In.</p>

<p>To get a clientId from the Plug-In, the GotAPI Server SHALL sends the data object to the Plug-In as defined blow:</p>

<table class="oma2"> 
<caption>Definition of the data object for the app registration request</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	</tr> 
	<tr>
		<td> receiver
		<td></td>
		<td>String
		<td>The address of the GotAPI Server application used by Plug-Ins. Generally, it is the application ID recognized by the OS, such as a package name.
		<td>Mandatory
	</tr> 
	<tr>
		<td> requestCode
		<td></td>
		<td>int
		<td>A request code identifying the request. This value could be any number but must be an integer greater than 0.
		<td>Mandatory
	</tr> 
	<tr>
		<td> api
		<td></td>
		<td>String
		<td>The value must be "gotapi".
		<td>Mandatory
	</tr> 
	<tr>
		<td> profile
		<td></td>
		<td>String
		<td>The value must be "authorization".
		<td>Mandatory
	</tr> 
	<tr>
		<td> attribute
		<td></td>
		<td>String
		<td>The value must be "createClient".
		<td>Mandatory
	</tr> 
	<tr>
		<td> package
		<td></td>
		<td>String
		<td>The identifier of the application. If the application is a web application running on a web browser, this value is the origin of the application. If the application is an OS-specific native application or a Hybrid Native/Web App, this value is the application ID recognized by the OS, such as a package name.
		<td>Mandatory
	</tr>  
</table>

<p>The GotAPI Server MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>Requirements for OS-specific request channel and data container</caption>
  	<thead>
		<tr> OS
		<tr> Description
	</thead>
	<tr>
		<td> Android
		<td>The GotAPI Server must use Explicit Intents for the request.</p>
<p>The data object must be mapped to the Extra directly.
	</tr>  
</table>

<table class="oma2"> 
<caption>Example of the Android Explicit Intent data object</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td> Action
		<td>
		<td>"org.deviceconnect.action.GET"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td> Component
		<td>
		<td>"org.example.plugin"
		<td>This value is the package name of the Plug-In application.
	</tr> 
	<tr>
		<td> Extra
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> receiver
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server application.
	</tr> 
	<tr>
		<td>
		<td> requestCode
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> api
		<td>"gotapi"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> profile
		<td>"authorization"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> attribute
		<td>"createClient"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> package
		<td>"http://example.com"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>  
</table>

<p>When the Plug-In receives the application registration request from the GotAPI Server, the Plug-In SHALL create a clientId for the application. The Plug-In MAY have a white-list of applications whose origin or application ID has been approved to access the Plug-In. If the application isn't found in the white-list, the Plug-In MAY deny this request. Note that the details of the approval of the origin of the applications is out of the scope this specification.</p>

<p>If the Plug-In accepts this request, the Plug-In SHALL send the data object to the GotAPI Server as defined below:</p>

<table class="oma2"> 
<caption>Definition of the data object for the app registration response</caption>
  	<thead>
		<th>Name
		<th>Sub name 
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	<tr>
		<td> requestCode
		<td></td>
		<td>int
		<td>The request code coming from the GotAPI Server.
		<td>Mandatory
	</tr> 
	<tr>
		<td> result
		<td></td>
		<td>int
		<td><p>If success, the value is 0, otherwise an integer greater than 0, which indicates an error code.</p>
		<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td> clientId
		<td></td>
		<td>String
		<td>The identifier of the application, which is generated by the Plug-In.
		<td>Mandatory
	</tr>  
</table>

<p>The Plug-In MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>OS-specific response channel and data container</caption>
  	<thead>
		<th>OS
		<th>Description
	</thead>
	<tr>
		<td> Android
		<td><p>The GotAPI Server must use Explicit Intents for the response.</p>
		<p>The data object must be mapped to the Extra directly.
	</tr>
</table>

<table class="oma2"> 
<caption>Example of the Android Explicit Intent data object</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td> Action
		<td>
		<td>"org.deviceconnect.action.RESPONSE"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td> Component
		<td>
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server application.
	</tr> 
	<tr>
		<td> Extra
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> requestCode
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> result
		<td>0
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> clientId
		<td>"123ABC"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>  
</table>
</section>

<section>
<h4>Request for an access token</h4>

<p>Immediately after the GotAPI Server has received a clientId from the Plug-In, the GotAPI Server SHALL send the data object to the Plug-In in order to get an access token as defined below:</p>

<table class="oma2"> 
<caption>Definition of the data object for the access token request</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	</thead>
	<tr>
		<td> receiver
		<td></td>
		<td>String
		<td>The address of the GotAPI Server application used by Plug-Ins. Generally, it is the application ID recognized by the OS, such as a package name.
		<td>Mandatory
	</tr> 
	<tr>
		<td> requestCode
		<td></td>
		<td>int
		<td>A request code identifying the request. This value could be any number but must be an integer greater than 0.
		<td>Mandatory
	</tr> 
	<tr>
		<td> serviceId
		<td></td>
		<td>String
		<td>The identifier of the targeted Service. This value is provided by the application over the GotAPI-1 Interface.
		<td>Mandatory
	</tr> 
	<tr>
		<td> api
		<td></td>
		<td>String
		<td>The value must be "gotapi".
		<td>Mandatory
	</tr> 
	<tr>
		<td> profile
		<td></td>
		<td>String
		<td>The value must be "authorization".
		<td>Mandatory
	</tr> 
	<tr>
		<td> attribute
		<td></td>
		<td>String
		<td>The value must be "requestAccessToken".
		<td>Mandatory
	</tr> 
	<tr>
		<td> package
		<td></td>
		<td>String
		<td>The identifier of the application. If the application is a web application running on a web browser, this value is the origin of the application. If the application is an OS-specific native application or a Hybrid Native/Web App, this value is the application ID recognized by the OS, such as a package name.
		<td>Mandatory
	</tr> 
	<tr>
		<td> clientId
		<td></td>
		<td>String
		<td>The identifier of the application, which is generated by the Plug-In.
		<td>Mandatory
	</tr>  
</table>

<p>The GotAPI Server MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>Requirements for OS-specific request channel and data container</caption>
  	<thead>
		<th>OS
		<th>Description
	</thead>
	<tr>
		<td> Android
		<td>The GotAPI Server must use Explicit Intents for the request.</p>
<p>The data object must be mapped to the Extra directly.
	</tr>  
</table>

<table class="oma2"> 
<caption>Example of the Android Explicit Intent data object</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td> Action
		<td>
		<td>"org.deviceconnect.action.GET"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td> Component
		<td>
		<td>"org.example.plugin"
		<td>This value is the package name of the Plug-In application.
	</tr> 
	<tr>
		<td> Extra
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> receiver
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server application.
	</tr> 
	<tr>
		<td>
		<td> requestCode
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> serviceId
		<td>"device1.localhost.deviceconnect.org"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> api
		<td>"gotapi"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> profile
		<td>"authorization"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> attribute
		<td>"requestAccessToken"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> package
		<td>"http://example.com"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> clientId
		<td>"123ABC"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>  
</table>

<p>When the Plug-In receives the access token request from the GotAPI Server, the Plug-In SHALL ask the user if the user permits the application to accesses the Plug-In. For example, the Plug-In MAY show a yes/no confirmation dialog box to the user.</p>

<p>If the user confirms permission for the application to access the Plug-In, the Plug-In SHALL create an access token, and send the data object to the GotAPI Server as defined below:</p>

<table class="oma2"> 
<caption>Definition of the data object for the access token response</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	<tr>
		<td> requestCode
		<td></td>
		<td>int
		<td>The request code coming from the GotAPI Server.
		<td>Mandatory
	</tr> 
	<tr>
		<td> result
		<td></td>
		<td>int
		<td><p>If success, the value is 0, otherwise an integer greater than 0, which indicates an error code.</p>
		<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr> 
	<tr>
		<td> accessToken
		<td></td>
		<td>String
		<td>The access token for the application, which is generated by the Plug-In.
		<td>Mandatory
	</tr> 
	<tr>
		<td> expire
		<td></td>
		<td>long
		<td>The unix time representing the expiration date of the access token.
		<td>Mandatory
	</tr>
</table>

<p>The Plug-In MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>Requirements for OS-specific response channel and data container</caption>
  	<thead>
		<th>OS
		<th>Description
	</thead>
	<tr>
		<td> Android
		<td>The GotAPI Server must use Explicit Intents for the response.</p>
<p>The data object must be mapped to the Extra directly.
	</tr>  
</table>

<table class="oma2"> 
<caption>Example of the Android Intent data object</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td> Action
		<td>
		<td>"org.deviceconnect.action.RESPONSE"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td> Component
		<td>
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server application.
	</tr> 
	<tr>
		<td> Extra
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> requestCode
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> result
		<td>0
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> accessToken
		<td>"0123456789abcdef"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> expire
		<td>1413423117
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>
</table>
</section>

<section>
<h3>Common data set on the GotAPI-4 Interface</h3>

<p>As described in the section "7.3.2.4.3 Data Forwarding", once a connection between the GotAPI Server and the targeted Plug-In is established (i.e., GotAPI-4 Plug-In Discovery and GotAPI-4 Approval have been successfully completed), the application can communicate with the targeted Plug-In. The GotAPI Server passes the data transferred between the application and the Plug-In transparently without any modification. But when the GotAPI Server communicates with the Plug-In on the GotAPI-4 interface, some information is to be added for the purpose of interoperability. This section defines the common data set.</p>

<p>The data names defined in the table below are reserved as the common data set for the request from the GotAPI Server to the Plug-In. When the GotAPI Server sends a request to the Plug-In, it SHALL send the data object defined in the table below. The GotAPI Server SHALL not use the data names defined in the table below for other purposes.</p>

<table class="oma2"> 
<caption>Definition of the common data set for the request from the GotAPI Server to the Plug-In</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	<tr>
		<td> receiver
		<td></td>
		<td>String
		<td>The address of the GotAPI Server application used by Plug-Ins. Generally, it is the application ID recognized by the OS, such as a package name.
		<td>Mandatory
	</tr> 
	<tr>
		<td> requestCode
		<td></td>
		<td>int
		<td>A request code identifying the request. This value could be any number but must be an integer greater than 0.
		<td>Mandatory
	</tr> 
	<tr>
		<td> serviceId
		<td></td>
		<td>String
		<td>The identifier of the targeted Service. This value is provided by the application over the GotAPI-1 Interface.
		<td>Mandatory
	</tr> 
	<tr>
		<td> api
		<td></td>
		<td>String
		<td>The value must be "gotapi".
		<td>Mandatory
	</tr> 
	<tr>
		<td> profile
		<td></td>
		<td>String
		<td>Plug-In specific function name. This specification doesn't define the name.
		<td>Mandatory
	</tr> 
	<tr>
		<td> attribute
		<td></td>
		<td>String
		<td>Plug-In specific attribute name. This specification doesn't define the name.
		<td>Mandatory
	</tr> 
	<tr>
		<td> clientId
		<td></td>
		<td>String
		<td>The identifier of the application, which is generated by the Plug-In.
		<td>Mandatory
	</tr> 
	<tr>
		<td> accessToken
		<td></td>
		<td>String
		<td>The access token for the application, which is generated by the Plug-In.
		<td>Mandatory
	</tr>  
</table>

<p>The GotAPI Server MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>Requirements for OS-specific request channel and data container</caption>
  	<thead>
		<th>OS
		<th>Description
	</thead>
	<tr>
		<td> Android
		<td><p>The GotAPI Server must use Explicit Intents for the request.</p>
		<p>The data object must be mapped to the Extra directly.
	</tr>  
</table>

<table class="oma2"> 
<caption>Example of the Android Intent data object</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td> Action
		<td>
		<td>"org.deviceconnect.action.GET"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td> Component
		<td>
		<td>"org.example.plugin"
		<td>This value is the package name of the Plug-In application.
	</tr> 
	<tr>
		<td> Extra
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> receiver
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server application.
	</tr> 
	<tr>
		<td>
		<td> requestCode
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> serviceId
		<td>"device1.localhost.deviceconnect.org"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> api
		<td>"gotapi"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> profile
		<td>"vibration"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> attribute
		<td>"vibrate"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> clientId
		<td>"123ABC"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> accessToken
		<td>"0123456789abcdef"
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>  
</table>

<p>The data names defined in the table below are reserved as the common data set for the response from the Plug-In to the GotAPI Server. When the Plug-In sends a response to the GotAPI Server, it SHALL send the data object defined in the table below. The Plug-In SHALL not use the data names defined in the table below for other purposes.</p>

<table class="oma2"> 
<caption>Definition of the common data set for the response from the Plug-In to the GotAPI Server</caption>
  	<thead>
		<th>Name
		<th>Sub name
		<th>Type
		<th>Definition of value
		<th>Mandatory/Optional
	<tr>
		<td> requestCode
		<td></td>
		<td>Number
		<td>The request code coming from the GotAPI Server.
		<td>Mandatory
	</tr> 
	<tr>
		<td> result
		<td></td>
		<td>Number
		<td><p>If success, the value is 0, otherwise an integer greater than 0, which indicates an error code.</p>
		<p>This specification doesn't define error codes.
		<td>Mandatory
	</tr>  
</table>

<p>The Plug-In MAY append additional data in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, .e.g., Intents for Android.</p>

<table class="oma2"> 
<caption>Requirements for OS-specific response channel and data container</caption>
  	<thead>
		<th>OS
		<th>Description
	</thead>
	<tr>
		<td> Android
		<td><p>The GotAPI Server must use Explicit Intents for the request.</p>
		<p>The data object must be mapped to the Extra directly.
	</tr>  
</table>

<table class="oma2"> 
<caption>Example of the Android Intent data object</caption>
  	<thead>
		<th>Name
		<th>
		<th>Example of value
		<th>Note
	</thead>
	<tr>
		<td> Action
		<td>
		<td>"org.deviceconnect.action.RESPONSE"
		<td>This value is defined by the GotAPI Server application.
	</tr> 
	<tr>
		<td> Component
		<td>
		<td>"org.deviceconnect"
		<td>This value is the package name of the GotAPI Server application.
	</tr> 
	<tr>
		<td> Extra
		<td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> requestCode
		<td>1
		<td></td>
	</tr> 
	<tr>
		<td>
		<td> result
		<td>0
		<td></td>
	</tr> 
	<tr>
		<td>
		<td><em>config</em>
		<td><em>"additional parameters"</em>
		<td><em>This name-value pair is an additional data which is not defined by this specification.</em>
	</tr>  
</table>

<p>The Plug-In MAY append additional name-value pairs in the data object as needed.</p>

<p>This data object is sent to the Plug-Ins in an OS specific mechanism, e.g., Intents for Android.</p>
</section>
</section>
</section>

<section>
<h1>Release Information</h1>

<section>
<h2>Supporting File Document Listing</h2>

<table class="oma1"> 
<caption>Listing of Supporting Documents in GotAPI 1.0 Release</caption>
  	<thead>
		<th>Doc Ref
		<th>Permanent Document Reference
		<th>Description
	</thead>
	<tr>
		<td></td>
		<td></td>
		<td></td>
	</tr> 
	<tr>
		<td></td>
		<td></td>
		<td></td>
	</tr> 
</table>
</section>

<section>
<h2>OMNA Considerations</h2>
</section>

<section>
<h1>Appendix A. Change History (Informative)</h1>

<section>
<h2>A.1 Approved Version History</h2>

<table class="oma1"> 
  	<thead>
		<th>Reference
		<th>Date
		<th>Description
	</thead>
	<tr>
		<td></td>
		<td></td>
		<td></td>
	</tr> 
</table>
</section>

<section>
<h2>A.2 Candidate Version History</h2>
<table class="oma1"> 
  	<thead>
		<th>Document Identifier
		<th>Date
		<th>Sections
		<th>Description
	</thead>
	<tr><td rowspan=10>Draft Version<br/>OMA-ER-GotAPI-V1_0</td>
	<tr><td>04 Feb 2014</td><td>All</td><td>Initial baseline document.
	<tr><td>03 June 2014</td><td></td><td>Updates for agreed CRs:<br/>
		OMA-CD-GotAPI-2014-0002-CR_GotAPI_ER_Updates<br/>
		OMA-CD-GotAPI-2014-0003-CR_Architecture<br/>
		OMA-CD-GotAPI-2014-0008-CR_GotAPI_URI_Scheme_and_Availability_API<br/>
		OMA-CD-GotAPI-2014-0007-CR_Multiple_GotAPI_Server_Support
	<tr><td>12 Aug 2014</td><td>Various</td><td>Updates for agreed CRs:<br/>
		OMA-CD-GotAPI-2014-0012R01-CR_Security_etc<br/>
		OMA-CD-GotAPI-2014-0013R01-CR_Technical_Outline
	<tr><td>25 Aug 2014</td><td>6.1, 7.3.2.1.1, 7.3.2.4</td><td>Updates for agreed CRs:<br/>
		OMA-CD-GotAPI-2014-0025R01-CR_AD_description_of_Temporary_Server_Feed__for_GotAPI_1<br/>
		OMA-CD-GotAPI-2014-0026R01-CR_Merged_Plug_In_CRs__0015R01_0020_0021_and_0022_
	<tr><td>6 Nov 2014</td><td>Various</td><td>Updates for agreed CRs:<br/>
		OMA-CD-GotAPI-2014-0028-CR_New_architecture_for_the_Plug_In_Discovery<br/>
		OMA-CD-GotAPI-2014-0030R03-CR_Section_8.6_GotAPI_Server<br/>
		OMA-CD-GotAPI-2014-0031R01-CR_Adding_GotAPI_Server_spoofing_attack_to_7.4.3<br/>
		OMA-CD-GotAPI-2014-0034R01-CR_Section_7.3.2.2_GotAPI_2<br/>
		OMA-CD-GotAPI-2014-0035R01-CR_8.7_GotAPI_Authorization_Server
	<tr><td>20 Nov 2014</td><td>Various</td><td>Updates for agreed CRs:<br/>
		OMA-CD-GotAPI-2014-0037-CR_CONR_1_Scope<br/>
		OMA-CD-GotAPI-2014-0038-CR_CONR_2_References<br/>
		OMA-CD-GotAPI-2014-0039-CR_CONR_5_GotAPI_Enabler_release_description<br/>
		OMA-CD-GotAPI-2014-0040-CR_CONR_6_Requirements<br/>
		OMA-CD-GotAPI-2014-0041-CR_CONR_7_Dependencies<br/>
		OMA-CD-GotAPI-2014-0042-CR_CONR_7_Architectural_Diagram<br/>
		OMA-CD-GotAPI-2014-0043-CR_CONR_7_GotAPI_Server<br/>
		OMA-CD-GotAPI-2014-0044-CR_CONR_7_GotAPI_Authorization_Server<br/>
		OMA-CD-GotAPI-2014-0045-CR_CONR_7_GotAPI_1<br/>
		OMA-CD-GotAPI-2014-0046-CR_CONR_7_GotAPI_2<br/>
		OMA-CD-GotAPI-2014-0047-CR_CONR_7_GotAPI_3<br/>
		OMA-CD-GotAPI-2014-0048-CR_CONR_7_GotAPI_4<br/>
		OMA-CD-GotAPI-2014-0049-CR_CONR_7_Confidentialty_and_Integrity<br/>
		OMA-CD-GotAPI-2014-0050-CR_CONR_7_Immunity_form_Attack<br/>
		OMA-CD-GotAPI-2014-0051-CR_CONR_8_Technical_Specifications
	<tr><td>04 Dec 2014</td><td>Various</td><td>Updates for agreed CRs:<br/>
		OMA-CD-GotAPI-2014-0052-CR_Hybrid_Apps<br/>
		OMA-CD-GotAPI-2014-0053-CR_Concept_of_Service_provided_by_Plug_In<br/>
		OMA-CD-GotAPI-2014-0054R03-CR_Various_Protocol_over_GotAPI_1
	<tr><td>04 Jan 2015</td><td>Various</td><td>Updates for agreed CRs:<br/>
		OMA-CD-GotAPI-2014-0057-CR_EventSource<br/>
		OMA-CD-GotAPI-2014-0058-CR_Editorial_in_Introduction<br/>
		OMA-CD-GotAPI-2014-0059-CR_Terminology_Clean_Up
	<tr><td>06 Jan 2015</td><td>4</td><td>Update for agreed CR:<br/>
		OMA-CD-GotAPI-2015-0001-CR_ER_Intro_Diagram<br/>
		OMA-CD-GotAPI-2015-0002-CR_getNetworkServices
	</tr> 
</table>
</section>
</section>

<section>
<h1>Appendix B Call Flows (Informative)</h1>
<p>This is a placeholder to be populated, as required.</p>
</section>

<section>
<h1>Appendix C. GotAPI Enabler Deployment Considerations</h1>
<p>This is a placeholder to be populated, as required.</p>
</section>

<section>
<h1>Appendix D. Plug-In Discovery Mechanisms for Android</h1>

<p>In order for the GotAPI Server to discover the installed Extension Plug-Ins, there are at least the following two mechanisms available on the Android platform.
<ol>
<li>GotAPI Server initiated search mechanism
	<p>When the GotAPI Server is invoked, the GotAPI Server searches installed Extension Plug-Ins using Android specific methods.
	<ol>
		<li>Android supports the getInstalledApplications() method of the PackageManager class, which provides the list of the installed applications. [ANDROID_INSTALLED_APPS]
		<li>When the GotAPI Server gets the list of the installed applications on the Android device, the GotAPI Server can find Extension Plug-In applications from the list. To identify which are the Extension Plug-Ins, the GotAPI Server can read the AndroidManifest.xml of each application, and determine if the application is an Extension Plug-In or not. [ANDROID_APP_MANIFEST]
		<p>Note: This specification does not define the way how to determine if an application is an Extension Plug-In or not. It is left to implementers of the GotAPI Server. Implementers of Extension Plug-Ins must follow the rules that are defined by each implementer of the GotAPI Server.</p>
		<li>The GotAPI Server must keep the list of the installed Extension Plug-In up-to-date during the GotAPI Server is running. To do so, the GotAPI Server must keep receiving events fired when new native applications are installed. Android supports the Broadcast Intent whose Action is "android.intent.action.PACKAGE_ADDED". [ANDROID_PACKAGE_ADDED]
		<li>If the GotAPI Server adopts this mechanism, the GotAPI doesn't need to store the list in a persistent storage, because the GotAPI Server is able to create a complete list of the installed Extension Plug-Ins whenever the GotAPI Server is invoked and keep the list up-to-date during the GotAPI Server is running.
	</ol>
	</p>
	<p>[References]</p>
	<dl>[ANDROID_INSTALLED_APPS]</dl>
	<dd>http://developer.android.com/reference/android/content/pm/PackageManager.html#getInstalledApplications(int)</dd>
	<dl>[ANDROID_PACKAGE_ADDED]</dl>
	<dd>http://developer.android.com/reference/android/content/Intent.html#ACTION_PACKAGE_ADDED</dd>
	<dl>[ANDROID_APP_MANIFEST]</dl>
	<dd>http://developer.android.com/guide/topics/manifest/manifest-intro.html</dd>
<li>Plug-In initiated registration mechanism
	<ol>
		<li>After an Extension Plug-In is installed and invoked, the Extension Plug-In invokes the GotAPI Server and sends a request for registration to the GotAPI Server. For Android, the Extension Plug-In uses Explicit Intents to talk to the GotAPI Server. The Extension Plug-In must know the package name of the GotAPI Server application and the provider of the GotAPI Server implementation must ensure that the package name of the GotAPI Server implementation is hardcoded in the Extension Plug-In.
		<li>The GotAPI Server polls all the registered Extension Plug-Ins periodically in order to determine if each Extension Plug-In is still installed.
		<li>If the GotAPI Server adopts this mechanism, the GotAPI has to store the list in a persistent storage and keep it up-to-date, because the GotAPI Server doesn't know the complete list when the GotAPI Server is invoked.
	</ol>
</ol>
</section>
</body>
</html>