<!DOCTYPE html>

<html lang="en-us">
<head>
  <link href="gotapi.css" rel="stylesheet" type="text/css">

  <title>Generic Open Terminal API (GotAPI)</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <!--
   To publish this document, see instructions in README
   -->

   <script src='js/require.js' data-main='js/profile-w3c-common' async class='remove'></script>
  <script class="remove" src="gotapi.js" type="text/javascript">
  <!-- keep this comment -->
  </script>
</head>

<body>
	<section id='title'>
	<img src="images/oma-logo.jpg"/>
	<table style="width: 100%">
	<tr><td style='float: right; font-size: 40px;'><b>Generic Open Terminal API Framework (GotAPI)</b></td>
	<tr><td style='float: right; font-size: 40px;'>Draft Version 1.0 – 5 Nov 2014</td>
	</td></table>
	<hr style="height: 2px;" />
	<table style="width: 100%"></td>
	<tr><td style='float: right; font-size: 40px;'><b>Open Mobile Alliance<b></td>
	<tr><td style='float: right; font-size: 40px;'>OMA-ER-GotAPI-V1_0-20141105-D</td></table>
	</section>
	
	<section id='copyright'>
	<p class='copyright'>Use of this document is subject to all of the terms and conditions of the Use Agreement located at <a href="http://www.openmobilealliance.org/UseAgreement.html">http://www.openmobilealliance.org/UseAgreement.html</a>.<br/>Unless this document is clearly designated as an approved specification, this document is a work in process, is not an approved Open Mobile Alliance™ specification, and is subject to revision or removal without notice.<br/>You may use this document or any part of the document for internal or educational purposes only, provided you do not modify, edit or take out of context the information in this document in any manner.  Information contained in this document may be used, at your sole risk, for any purposes.  You may not use this document in any other manner without the prior written permission of the Open Mobile Alliance.  The Open Mobile Alliance authorizes you to copy this document, provided that you retain all copyright and other proprietary notices contained in the original materials on any copies of the materials and that you comply strictly with these terms.  This copyright permission does not constitute an endorsement of the products or services.  The Open Mobile Alliance assumes no responsibility for errors or omissions in this document.<br/>Each Open Mobile Alliance member has agreed to use reasonable endeavors to inform the Open Mobile Alliance in a timely manner of Essential IPR as it becomes aware that the Essential IPR is related to the prepared or published specification.  However, the members do not have an obligation to conduct IPR searches.  The declared Essential IPR is publicly available to members and non-members of the Open Mobile Alliance and may be found on the OMA IPR Declarations list at <a href="http://www.openmobilealliance.org/ipr.html">http://www.openmobilealliance.org/ipr.html</a>.  The Open Mobile Alliance has not conducted an independent IPR review of this document and the information contained herein, and makes no representations or warranties regarding third party IPR, including without limitation patents, copyrights or trade secret rights.  This document may contain inventions for which you must obtain licenses from third parties before making, using or selling the inventions.  Defined terms above are set forth in the schedule to the Open Mobile Alliance Application Form.<br/>NO REPRESENTATIONS OR WARRANTIES (WHETHER EXPRESS OR IMPLIED) ARE MADE BY THE OPEN MOBILE ALLIANCE OR ANY OPEN MOBILE ALLIANCE MEMBER OR ITS AFFILIATES REGARDING ANY OF THE IPR’S REPRESENTED ON THE 'OMA IPR DECLARATIONS' LIST, INCLUDING, BUT NOT LIMITED TO THE ACCURACY, COMPLETENESS, VALIDITY OR RELEVANCE OF THE INFORMATION OR WHETHER OR NOT SUCH RIGHTS ARE ESSENTIAL OR NON-ESSENTIAL.<br/>THE OPEN MOBILE ALLIANCE IS NOT LIABLE FOR AND HEREBY DISCLAIMS ANY DIRECT, INDIRECT, PUNITIVE, SPECIAL, INCIDENTAL, CONSEQUENTIAL, OR EXEMPLARY DAMAGES ARISING OUT OF OR IN CONNECTION WITH THE USE OF DOCUMENTS AND THE INFORMATION CONTAINED IN THE DOCUMENTS.<br/>© 2014 Open Mobile Alliance Ltd.  All Rights Reserved.<br/>Used with the permission of the Open Mobile Alliance Ltd. under the terms set forth above.<br/></p>
	<hr style="height: 2px;" />
	</section>
	
	<section id='abstract'>
	<p>This Enabler Release (ER) document is a combined document that includes requirements, architecture and technical specification of the Generic Open Terminal API Framework (GotAPI) Enabler.</p>
	<p>The scope of this enabler will include:</p>
	<ul><td>Architecture and specifications for an API framework enabling web-based APIs to be exposed to apps running in web browsers and as native apps (including but not limited to hybrid native/web apps)<td>Supporting assets for the localhost API server framework, e.g. JavaScript libraries enabling abstractions of common API functions (e.g. discovery, access, and session management)<td>A registry of well-known API resources for OMA enablers, to be maintained as part of the OMNA<td>Specification of API exposure patterns that are in general globally applicable to native device platforms
	</ul>
	</section>
	
	<section id="introduction">
	<h2>Introduction</h2>
	<p>The concept of a common OMA device API framework, through which OMA enablers can be exposed to applications executing in various execution environments, has been a discussion thread in OMA for several years. For the web, the discussion started with Client Side Enabler API [CSEA] work item, and followed by the Web Runtime API [WRAPI] work item which established an initial pattern for OMA API exposure to web applications, focused on the requirements of the OMA Push enabler. The need for more broadly applicable API patterns was recognized during development of APIs for the Mobile Codes 2.0 [MCAPI] enabler and the Open Connection Management 1.1 API [CMAPI] enabler. Interest in incorporating the WRAPI local API server concept has further been expressed for the RCS-enabling enablers of COM, and the Device Management enablers, among others.</p> 
	<p>This specification defines a variety of API exposure patterns for use in development of OMA enablers, and the functions required by API servers that support those exposure patterns. APIs designed per these patterns are intended to be “web-based” (i.e. accessed via the use of web technologies) and exposed to apps running in the following contexts:</p>
	<ul><td>Web Browser apps, i.e. web apps running in a window of a web browser<td>Web  Runtime apps, i.e. web apps running outside a browser, e.g. under a Widget Engine or other “chromeless” runtime for execution of web content as standalone apps<td>Hybrid Native/Web apps, i.e. apps that run web content through native APIs for that purpose<td>Native Apps that directly use native platform APIs (e.g. HTTP, Socket, and Datagram) enabling use of the web-related protocols described in this document. Though not leveraging a full web execution environment, such apps can use the same network-based APIs as web apps.
	</ul>
	<p>For simplicity, the web API client environment provided by each of these contexts is referred to here as the User Agent (UA). The OMA enabler clients that expose APIs via the GotAPI patterns are referred to here as the GotAPI Server. GotAPI Servers may also act as OAuth servers for other GotAPI Servers, and in that role are referred to here as GotAPI OAuth Servers.</p>
	<p>The web-based methods defined by GotAPI are intended to offer a flexible set of options for OMA enablers to expose their services to apps via web-based APIs. Such APIs are primarily intended to be exposed to apps running in the device hosting the OMA enabler client, but in principle could also be exposed to apps  in other devices that are networked with the OMA enabler client host device.</p>
	<p>The exposure of OMA enabler-based services via such web-based APIs is intended to broaden the reach of OMA enabler deployments, by making it possible for web apps to access them, without explicit UA support of APIs specifically designed per the requirements of OMA enablers.</p>
	<p>The figure below illustrates the relationships and conceptual interfaces between web apps, the UA, GotAPI-specified functions (shaded), and other OMA-specified functions.</p>
	
	<figure id="l" style="display: table; width: 60%; text-align: center;">
	<figcaption><b>Conceptual Implementation (Informative)</b></figcaption>
	<img src="images/Conceptual_Implementation_Informative.png" style="width: 80%; align: center;"/>
	</figure>

	<p>In the figure above:<ul><td>The GotAPI functions include the GotAPI Server (including optionally acting as a distinct OAuth server) and a database of API access permissions.<td>The device OS provides intra-device and inter-device communication via network protocols such as HTTP, Socket (TCP), and Datagram (UDP), via which the web-based APIs can be exposed.<td>The access permissions database is logically specified per its supporting operations and policy structure, but interfaces to it are unspecified by GotAPI. <td>Interfaces to other OMA enabler clients are also unspecified.<td>GotAPI Servers may expose APIs for multiple OMA enablers, and either directly implement the related OMA enabler functions or as above use unspecified interfaces exposed by the specific OMA enabler clients.<td>User interface functions can include a variety of means for assessing user consent for API access by apps, including basic means such as device display and keyboard, or more advanced means such as Trusted User Interfaces (TUI) or biometrics. 
	</ul></p>
	</section>
	
	<section id="version1.0">
	<h2>Version 1.0</h2>
	<p>GotAPI version 1.0 includes the functionality:<ul><td>Architecture and specifications for GotAPI Servers and GotAPI OAuth Servers in an API framework enabling web-based APIs to be exposed apps running in web browsers and as native apps (including but not limited to hybrid native/web apps)<td>Supporting assets for the localhost API server framework, e.g. JavaScript libraries enabling abstractions of common API functions (e.g. discovery, access, and session management)<td>A registry of well-known API resources for OMA enablers, to be maintained as part of the OMNA<td>Specification of API exposure patterns that are in general globally applicable to native device platforms
	</ul></p>
	</section>
	
	<section id="release_description">
	<h2>GotAPI Enabler release description (Informative)</h2>
	<p>This release focuses on the functions of GotAPI Servers and GotAPI OAuth Servers, through which OMA enabler based services can be exposed and access to the APIs managed.</p>
	</section>
	
	<section id="requirements">
	<h2>Requirements (Normative)</h2>
	<section id="highlevel-requirements">
	<h3>High-Level Functional Requirements</h3>
	<p>The following requirements outline the high-level set of options that GotAPI Servers may implement. The GotAPI technical specifications will address the necessary functions for support of these options.</p>

	<table border=1>
	<caption>High-Level Functional Requirements</caption>
	<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
	<thead>
	<th>Label
	<th>Description
	<th>Release</thead>
	<tr><td>GotAPI-HLF-01<td>GotAPI Servers SHALL support APIs exposed via HTTP/1.1 [HTTP/1.1].<td>1.0
	<tr><td>GotAPI-HLF-02<td>GotAPI Servers SHALL support APIs exposed via custom URI scheme handlers.<td>1.0
	<tr><td>GotAPI-HLF-03<td>GotAPI Servers SHOULD support APIs exposed via the WebSocket API [WebSocket].<td>1.0
	<tr><td>GotAPI-HLF-04<td>GotAPI Servers SHOULD support APIs exposed via the EventSource API [EventSource].<td>1.0
	<tr><td>GotAPI-HLF-05<td>GotAPI Servers MAY support APIs exposed via the WebRTC API [WebRTC].<td>1.0
	<tr><td>GotAPI-HLF-06<td>GotAPI Servers MAY support APIs exposed via HTTP/2.0  [HTTP/2.0].<td>1.0
	<tr><td>GotAPI-HLF-07<td>GotAPI Servers SHALL support APIs exposed using the REST design pattern.<td>1.0
	<tr><td>GotAPI-HLF-08<td>GotAPI Servers SHALL support APIs exposed using the RPC design pattern, including APIs exposed using JSON-RPC 2.0 [JSON-RPC] as payload protocol.<td>1.0
	<tr><td>GotAPI-HLF-09<td>GotAPI Servers MAY support APIs that include transfer of any discrete media type.<td>1.0
	<tr><td>GotAPI-HLF-10<td>GotAPI Servers MAY support APIs that include transfer of any streamed media type.<td>1.0
	<tr><td>GotAPI-HLF-11<td>GotAPI Servers SHALL expose APIs to UAs in the GotAPI Server host device.<td>1.0
	<tr><td>GotAPI-HLF-12<td>GotAPI Servers MAY expose APIs to UAs in devices other than the GotAPI Server host device.<td>1.0
	<tr><td>GotAPI-HLF-13<td>Multiple GotAPI Servers SHALL be implementable and functional simultaneously on a device where possible.<td>1.0
	<tr><td>GotAPI-HLF-14<td>GotAPI SHALL support an API that provides applications with availability of GotAPI in the device in response to query requests from the application.<td>1.0
	<tr><td>GotAPI-HLF-15<td>GotAPI Servers SHALL support invocation via a custom URI scheme, to startup the server when it is not running.<td>1.0
	<tr><td>GotAPI-HLF-16<td>GotAPI Server SHALL expose an interface to communicate with external devices and internal enablers, so that different manufacturers are able to develop Extension Plug-Ins for the GotAPI Server, and application developers are able to develop applications that can communicate with such other external devices and internal enablers through GotAPI Server. Note: The APIs for each device or enabler are out of the scope of this specification.<td>1.0
	</table>
	</section>
	
	<section id="security-privacy">
	<h3>Security and Privacy</h3>
	<p>The following requirements address the generic security and privacy enabling features of GotAPI Servers.</p>
	
	<table border=1>
	<caption>High-Level Functional Requirements – Security and Privacy Items</caption>
	<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
	<thead>
	<th>Label
	<th>Description
	<th>Release</thead>
	<tr><td>GotAPI-SEC-01<td>For clients in the host device, GotAPI Servers MAY support APIs exposed over TLS 1.2-secured connections.<td>1.0
	<tr><td>GotAPI-SEC-02<td>For clients in other devices, GotAPI Servers SHALL support APIs exposed over TLS 1.2-secured connections.<td>1.0
	<tr><td>GotAPI-SEC-03<td>GotAPI Servers SHALL support measures to minimize security risks including Intrusion and Denial-of-Service attacks.	<td>1.0
	</table>
	</section>

	<section id="Authentication-Authorization">
	<h3>Authentication and Authorization</h3>
	<p>The following requirements address the ability of GotAPI Servers to identify API client apps and manage access to APIs.</p>
	<table border=1>
	<caption>High-Level Functional Requirements – Authentication and Authorization Items</caption>
	<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
	<thead>
	<th>Label
	<th>Description
	<th>Release</thead>
	<tr><td>GotAPI-AUTH-01<td>GotAPI Servers SHALL support Cross-Origin Resource Sharing.<td>1.0
	<tr><td>GotAPI-AUTH-02<td>GotAPI Servers SHALL support management of API access permissions.<td>1.0
	<tr><td>GotAPI-AUTH-03<td>GotAPI Servers MAY support OAuth-based API access.<td>1.0
	<tr><td>GotAPI-AUTH-04<td>GotAPI Servers MAY act as an OAuth 2.0 [OAuth2.0] server for authorization of API access permissions.<td>1.0
	<tr><td>GotAPI-AUTH-05<td>GotAPI Servers MAY support user interfaces (UI) via which users authorize API access permissions.<td>1.0
	<tr><td>GotAPI-AUTH-06<td>GotAPI Servers MAY support pre-configured, fixed API access permissions.<td>1.0
	<tr><td>GotAPI-AUTH-07<td>GotAPI Servers MAY support dynamic, updatable API access permissions.<td>1.0
	<tr><td>GotAPI-AUTH-08<td>GotAPI Servers MAY support API access permissions managed through OMA Device Management.<td>1.0
	</table>
	</section>

	<section id="Data Integrity">
	<h3>Data Integrity</h3>
	<p>The following requirements address the ability of GotAPI Servers to protect the integrity of data transferred via APIs.</p>
	<table border=1>
	<caption>High-Level Functional Requirements – Data Integrity Items</caption>
	<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
	<thead>
	<th>Label
	<th>Description
	<th>Release</thead>
	<tr><td>GotAPI-DATI-01<td>GotAPI Servers SHOULD support data integrity for all data exchanged with clients.<td>1.0
	<tr><td>GotAPI-DATI-02<td>GotAPI Servers SHOULD support data integrity verification via digitally signed API request/response payloads,<td>1.0
	</table>
	</section>

	<section id="Confidentiality">
	<h3>Confidentiality</h3>
	<p>The following requirements address the ability of GotAPI Servers to protect the confidentiality of data transferred via APIs.</p>
	<table border=1>
	<caption>High-Level Functional Requirements – Confidentiality Items</caption>
	<col style="width: 20%"/><col style="width: 75%"/><col style="width: 5%"/>
	<thead>
	<th>Label
	<th>Description
	<th>Release</thead>
	<tr><td>GotAPI-CONF-01<td>GotAPI Servers SHOULD support confidentiality for all data exchanged with clients.<td>1.0
	<tr><td>GotAPI-CONF-02<td>GotAPI Servers SHOULD support data confidentiality via encrypted API request/response payloads,<td>1.0
	</table>
	</section>
	</section>

	<section id="Architectural-Model">
	<h1>Architectural Model</h2>
	<p>This section describes the architectural model and related aspects of the GotAPI Enabler.</p>
	<p>The architecture definition and functionalities are based on the requirements defined in the Section 6.</p>

	<section id="Dependencies">
	<h2>Dependencies</h2>
	<p>TBD</p>
	</section>
	
	<section id="Architectural-Diagram">
	<h2>Architectural Diagram</h2>
	<figure id="2" style="display: table; width: 60%; text-align: center;">
	<figcaption><b>GotAPI Architectural Diagram</b></figcaption>
	<img src="images/Architecture_Diagram.png" style="width: 80%; align: center;"/>
	</figure>
	</section>
	
	<figure id="3" style="display: table; width: 60%; text-align: center;">
	<figcaption><b>GotAPI Architectural Diagram - Informative</b></figcaption>
	<img src="images/Architecture_Diagram_Informative.png" style="width: 80%; align: center;"/>
	</figure>
	
	<section id="Architectural-Diagram">
	<h2>Functional Components and Interfaces/reference points definition</h2>
	
	<section id="Functional-Components">
	<h3>Functional Components</h2>
	<section id="GotAPI-Server">
	<h4>GotAPI Server</h4>
	<p>The GotAPI Server provides the following functions:
	<ul><li>Exposure of the GotAPI-1 interface, via which Applications can issue API requests and receive responses
	<li>Binding of the GotAPI-1 interface to various specific interface technologies and payload protocols / design patterns. 
	<li>Security and privacy protection for requests via the GotAPI-1 interface
	<li>Protection of the GotAPI-1 interface from Intrusion and Denial of Service attacks
	</ul></p>
	</section>

	<section id="GotAPI-Authorization-Server">
	<h4>GotAPI Authorization Server</h4>
	<p>The GotAPI Authorization Server provides the following functions:
	<ul><li>Exposure of the GotAPI-2 interface, via which Applications can obtain authorization to make API requests
	<li>User Interface functions as required to locally provide user information and consent for API access by applications
	<li>Acting as a proxy for user consent obtained through host-device external functions (e.g. OAuth servers)
	<li>Database of authorizations and user consent history
	<li>Binding of the GotAPI-2 interface to various specific interface technologies and payload protocols / design patterns. 
	<li>Security and privacy protection for requests via the GotAPI-2 interface
	<li>Protection of the GotAPI-2 interface from Intrusion and Denial of Service attacks
	<li>Exposure of the GotAPI-3 interface via which GotAPI authorizations can be provisioned through OMA Device Management
	</ul></p>
	</section>
	</section>

	<section id="Interfaces">
	<h3>Interfaces</h3>
	
	<section id="GotAPI-1">
	<h4>GotAPI-1</h4>
	<p>The GotAPI-1 interface enables applications to make API requests and receive responses. This interface is generically specified by GotAPI, as GotAPI-based API specifications will define specific request/response transactions that can be utilized in host devices based upon the available interface technologies, payload protocols, and their applicable design patterns. These options include:
	<ul><li>The interface technologies TLS 1.2, HTTP/1.1, HTTP/2, WebSockets, EventSource, WebRTC, and URI scheme handling
	<li>The design patterns REST and JSON-RPC
	<li>The Temporary Server Feed (TSF) mechanism for binary data responses, as described below
	</ul></p>
	
	<section id="tsf">
	<h5>The Temporary Server Feed (TSF) Mechanism</h5>
	<p>There are two possible approaches which the GotAPI Server returns API result data to applications:
	<ul><li>Direct response approach:
		<ul><li>GotAPI Server returns binary data as a response directly
		<li>This approach is very common and GotAPI-1 already supports it
		</ul>
	<li>Temporary Server Feed (TSF) approach:
		<ul><li>When an app request something to the GotAPI Server on GotAPI-1, the GotAPI Server creates a temporary URI for the requested data, then return it to the app with additional information
		<li>Then the app accesses the URI in order to fetch the binary data
		</ul>
	</ul></p>
	
	<p>The TSF approach has advantages below:
	<ul><li>Flexible API design
		<ul><li>The TSF mechanism brings flexibility to API design for GotAPI-1
		<li>APIs can provide additional information relevant to the requested binary data with applications
		<li>For example, APIs can provide adaptive streaming protocols over HTTP, such as SME + MPEG-DASH
			<ol><li>An application requests MPD (Media Presentation Description) data over GotAPI-1
			<li>The application fetches fragments of the video data sequentially following the URLs defined in the MPD
			</ul>
		<li>Web developer friendly
			<ul><li>Lots of existing server-side Web APIs on the Internet provide APIs similar to TSF with developers
			</ul>
		</ul>
	</ul>
	
	<p>The GotAPI Server MAY support the TSF mechanism.</p>
	<p>If the GotAPI Server supports the TSF mechanism, the GotAPI Server SHALL support the following steps for data retrieved via a TSF:
	<ol><li>An application sends a request for accessing certain data to the GotAPI Server over the GotAPI-1.
	<li>When the GotAPI Server receives the request, the GotAPI Server creates a non-predictable random URI for the binary data that is requested, and associates the URI with the binary data. 
	<li>The GotAPI Server sends a response with the URI and additional information (if needed) to the application over the GotAPI-1.
	<li>Receiving the URI, the application accesses the URI in order to get the requested binary data from the GotAPI Server. The GotAPI Server works as a Web server.
	<li>The GotAPI Server discards the URI after the application gets the binary data and/or after certain while for the purpose of security.
	</ol></p>

	<p>Example:</p>
	
	<figure id="4" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>The TSF Procedure</b></figcaption>
	<img src="images/The_TSF_Procedure.png" style="width: 80%; align: center;"/>
	</figure>
	</section>
	</section>
	
	<section id="GotAPI-2">
	<h4>GotAPI-2</h4>
	<p>The GotAPI-2 interface enables applications to obtain authorization for access to GotAPI-based APIs. This interface is fully specified by GotAPI, being a common (though optionally used) support function for all GotAPI-based APIs. GotAPI-2 supports bindings and request/response transactions that can be utilized in host devices based upon the available interface technologies. These options include the interface technologies TLS 1.2, HTTP/1.1, HTTP/2, and URI scheme handling.</p>
	<p>The GotAPI-2 interface is based upon the concepts of OAuth, though with different semantics as necessary for adaptation to the available interface technologies.</p>
	<p>In this specification, an "origin" is an identifier of an application, which is globally unique.</p>
	<p>If the application is a web application, the origin is literally an origin as defined by RFC6454, which is a concatenating string that is composed of the scheme, the fully qualified host name, and the TCP port number. For example, if the URL of a web application is "https://app.example.com:443/index.html", the origin is "https://app.example.com:443".</p>
	<p>If the application is an OS-specific native application, the origin is an application identifier managed by the underlying OS, such as a package name. For example, if the OS is Android, the origin could be "com.example.app".</p>
	<p>The origin is embedded in the HTTP request header by the application itself or by the web browser automatically as described in the section "8.7 GotAPI Authorization Server".</p>
	<p>The authenticity of the origin of the application is crucial for the entire operation of the GotAPI system.</p>
	<p>The GotAPI Auth Server SHALL be able to extract the origin from the HTTP request header appropriately.</p>
	
	<section id="Basic-GotAPI-2-Interface-Procedures">
	<h5>Basic GotAPI-2 Interface Procedures</h5>
	<p>The GotAPI-2 Interface must be able to run the steps as follows:
	<ol><li>Authorization of application
		<ol><li>The application sends an authorization request to the GotAPI Auth Server with the origin. 
		<li>The GotAPI Auth Server MAY support a white-list of origins that have been pre-authenticated by the GotAPI service provider. If the GotAPI Auth Server supports such a white-list and the origin is listed in the white-list, the GotAPI Auth Server MAY determine if the application is acceptable or not.
		<li>If the GotAPI Auth Server accepts the application, the GotAPI Auth Server SHALL create a series of random digits, called as “grant”, that is long enough not to be predicted, and, then, SHALL send the response to the application with the grant.
		</ol>
	<li>Issuance of an access token
		<ol><li>When the application receives the grant from the GotAPI Auth Server, it immediately sends an access token request to the GotAPI Auth Server with the origin, the grant, and the scopes which are functions the application wants to use. When the GotAPI Auth Server receives the request, the GotAPI Auth Server SHALL ask the user if the application may use the requested scopes (functions). In practice, the GotAPI Auth Server shows an OS-specific dialog box to the user.
		<li>The GotAPI Auth Server SHALL show the items in the dialog box as below:
			<ul><li>The information of the application (e.g. the origin of the web application or the package name of the OS-specific native application)
			<li>The list of the functions which the application want to use (scopes)
			<li>A button which the user presses if the user accepts the application
			<li>A button which the user presses if the user declines the application
			</ul>
		<li>If the user declines the request, the GotAPI Auth Server SHALL NOT allow the application to proceed any further beyond the point.
		<li>When the GotAPI Auth Server accepts the request, the GotAPI Auth Server SHALL create an access token for the application, which is a series of random digits that is long enough not to be predicted. Then the GotAPI Auth Server SHALL send the response with the access token to the application.
		<li>The application subsequently sends API requests with the access token on the GotAPI-1 Interface.
		</ol>
	</ol></p>
	</section>

	<section id="Security-Enforced-GotAPI-2-Interface-Procedures">
	<h5>Security-Enforced GotAPI-2 Interface Procedures</h5>
	<p>In addition to the basic GotAPI-2 Interface procedures as described above, there are two security concerns for the GotAPI-2 Interface that needs to be addressed.
	<ul><li>GotAPI Auth Server spoofing
	<li>Application’s origin spoofing
	</ul>

	<p style="text-decoration: underline">GotAPI Auth Server spoofing:</p>
		<p>GotAPI Auth Server spoofing is an attack where a bogus GotAPI Auth Server takes over the genuine GotAPI Auth Server and pretends as if it was the GotAPI Auth Server. When the application sends a request to the GotAPI Server for the first time, there may even be a case where the GotAPI Server has already been taken over by the attacker.</p>
		<p>Since GotAPI Auth Server spoofing is an easy-to-do attack, applications need to be able to verify if the GotAPI Auth Server is genuine or not. The HMAC server authentication resolves this spoofing attack.</p>
		<p>The GotAPI Auth Server SHOULD be able to support the HMAC server authentication using the Trusted Channel with the Application ID as described in the section 7.4.3.2</p>
	<p style="text-decoration: underline">Application origin spoofing:</p>
		<p>Application origin spoofing is an attack where a malicious application acts as other application by sending a fake identity (a.k.a. origin) to the GotAPI Auth Server. The GotAPI Auth Server needs to be able to verify if the identity that it has received from the application is authentic or not.</p>
		<p>When an application sends a request for authentication over the GotAPI-2 Interface, the origin of the application is included in the HTTP request header.</p>
		<p>If the application is a web application running on a web browser, the application cannot override the Origin header in the HTTP request header [W3C XHR]. Therefore, the origin coming from a web application is trustable.</p>
		<p>On the other hand, if the application is an OS-specific native application, the application may send a fake identity in the HTTP request header. Besides, a malicious native application may set the Origin header to be a fake origin pretending a web application running on a web browser.</p>
		<p>When an application sends a request for authentication, the GotAPI Auth Server SHOULD be able to verify the origin coming from the application to determine if the origin is authentic or not.</p>
		<p>The verification needs to depend on the features of the underlying OS domain on which the GotAPI Auth Server is running.</p>
	
	<p>An example of such a verification mechanism if the underlying OS is Android: 
	<ul><li>Android supports the netstat command by default. But it does not provide the process ID of the native application establishing the HTTP connection.
	<li>Using Android NDK, however, the full-featured netstat can be built and packaged within an Android native application (i.e., GotAPI Server application).
	<li>The GotAPI Auth Server embedding the full-featured netstat identifies the process ID of the native application from the result of the full-featured netstat, and it can get the package name and application name from the process ID using the Android API.
	<li>The GotAPI Auth Server uses a white-list of application names of legitimate browsers that have been verified to be compliant to the origin header’s not-over-ridden requirements [W3C XHR]. The white-list enables the GotAPI Auth Server to distinguish the case of (i) a web application declaring an origin from (ii)  a malicious native application fakes origin header to pretend a web application.
	</ul></p>
	
	<p>The Table below shows all the cases where an attacking native application, com.attacker.app, declares various origins in the HTTP header and what the netstat can find. As shown in the table, the faked origins can be completely found by the netstat.</p>

	<table border=1>
	<caption>Cases of origins declaration by attacking native application and what the netstat can find</caption>
	<col style="width: 20%"/><col style="width: 20%"/><col style="width: 20%"/>%"/><col style="width: 20%"/>%"/><col style="width: 20%"/>
	<thead>
	<th>Real package name
	<th>Declared origin in HTTP header
	<th>True/Fake
	<th>What netstat finds
	<th>Results
	<th>Notes</thead>
	<tr><td>com.attacker.app<td>http://example.com<td>Fake<td>com.attacker.app<td>Fake found<td>*1
	<tr><td>com.attacker.app<td>com.example.app<td>Fake<td>com.attacker.app<td>Fake found<td>*2
	<tr><td>com.attacker.app<td>com.attacker.app<td>True<td>com.attacker.app<td>True confirmed<td>*3
	</table>

	<ol><li> If the declaration of the origin was from a web application running in a legitimate browser, the netstat should have found the name of the browser that is registered in the white-list of legitimate browsers, instead of the package name of the attacking native application, com.attacker.app.
	<li>The package name that the netstat has found is different from the origin that the application is declaring in the HTTP header.
	<li>GotAPI Auth Server confirms what the native application is declaring in the HTTP header is authentic.
	</ol>
	
	<p>The figure below shows the procedure of application authorization on the GotAPI-2 Interface including the security enforced measures against the threats, GotAPI Auth Server spoofing, and application origin spoofing.</p>
	
	<p>In order to prevent GotAPI Auth Server spoofing and application’s origin spoofing, the GotAPI Auth Server SHOULD be able to support the security enforced GotAPI-2 Interface procedures as described in the figure below.</p>
	
	<figure id="5" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>Procedure of security enforced application authorization on the GotAPI-2 Interface</b></figcaption>
	<img src="images/security_enforced_application_authorization.png" style="width: 80%; align: center;"/>
	</figure>
	</section>
	</section>
	
	<section id="7.3.2.3">
  <h4>GotAPI-3</h4>
  <p>The GotAPI-3 interface enables the remote provisioning of API access authorizations through a policy management function, which may include one or more of:</p>
  <ul>
    <li>OMA Device Management, using a Managed Object (MO) defined by the GotAPI enabler [GotAPI MO]</li>
    <li>An implementation-specific policy management service</li>
  </ul>
	</section>
	
	<section id="7.3.2.4">
  <h4>GotAPI-4</h4>
  <p>The GotAPI-4 interface enables Extension Plug-Ins for external devices and internal enablers through which they communicate with the GotAPI Server. Note that host-device-internal enablers/applications may also be connected to GotAPI servers directly in implementation specific ways without using the GotAPI-4 interface and Extension Plug-Ins.</p>
  <p>The Extension Plug-Ins are independent applications. They are the mediators between the GotAPI Server, and external devices and internal enablers/applications. Typically, there are expected to be multiple Extension Plug-In applications installed on a device by the user or preinstalled on the device. An Extension Plug-In application may be developed:</p>
  <ul>
    <li>For a group of devices, e.g., a series of devices from a company, or a single device or an enabler,</li>
    <li>By a developer that is different from the provider of GotAPI or applications that use the devices or enablers through the Extension Plug-In.</li>
  </ul>
  <p>The GotAPI-4 interface provides the following functions with respect to Extension Plug-Ins:</p>
  <ul>
    <li>Plug-In Discovery: GotAPI-4 Plug-In Discovery enables the GotAPI Server to discover the targeted Extension Plug-In which an application wants to access and communicate with.</li>
    <li>Service Discovery: GotAPI-4 Service Discovery enables the GotAPI Server to find all the services provided by an Extension Plug-In. In this context, the "service" means an external device or a function provided by an internal enabler through an Extension Plug-In. The Service Discovery provides not only the list of services but also the availability of each service at the time.</li>
    <li>Approval: GotAPI-4 Approval is the function to ensure security, especially to protect users’ data and privacy from unwanted exploits, so that the users can safely use the application with external devices and enablers that are connected via Extension Plug-Ins.</li>
    <li>Data Forwarding: GotAPI-4 Data Forwarding is the function that enables an application to communicate with the targeted Extension Plug-In through the GotAPI Server. Data Forwarding takes place after Plug-In Discovery (optional) and Approval processes have been successfully completed. GotAPI-4 Data Forwarding uses the “pass-through” mechanism, so that the application can access and communicate with the APIs that (i) are implemented in the Extension Plug-In and (ii) expose the features of the external devices or internal enablers.</li>
  </ul>
  <p>Note that the APIs to be implemented in Extension Plug-Ins that expose features of external devices and internal enablers are out of the scope of this specification.</p>
	
	<section id="7.3.2.4.1">
  <h5>Plug-In Discovery</h5>
  <p>When applications use Extension Plug-Ins through the GotAPI Server, the GotAPI Server has to know what Extension Plug-Ins are installed. This section describes how the GotAPI Server discovers the installed Extension Plug-Ins in the local devices. </p>
  <p>Therefore:</p>
  <ul>
    <li>The GotAPI SHALL support the Plug-In Discovery if GotAPI-4 is supported.</li>
    <li>The GotAPI Server SHALL support a mechanism to know what Plug-Ins are installed in the local device.</li>
  </ul>
  <p>To discover the installed Extension Plug-Ins, the GotAPI Server has to use OS-specific mechanisms and functions. Regarding Android, see the section "Appendix F. Finding the installed Plug-Ins for Android".  </p>
  <p>Note: how the GotAPI Server discovers Extension Plug-Ins is out of the scope of this specification.</p>
  <p>How to ensure that Extension Plug-Ins on an OS from different vendors are able to be discovered by a GotAPI Server implementation is the responsibility of the provider of the GotAPI Server implementation.</p>
	</section>
	
	<section id="7.3.2.4.2">
  <h5>Service Discovery</h5>
  <p>In many cases, one Extension Plug-In is associated with one external device. Some Extension Plug-Ins are associated with multiple external devices. Some Extension Plug-Ins provide functions that work in the local device but is not associated with any external device (a.k.a. an internal enabler itself). Such external devices or functions are called "services".</p>
  <p>When an application wants to use a service, it needs to specify the identifier of the service rather than the Extension Plug-In that is supporting the service. Applications basically don't care about what Extension Plug-In is associated with the service.</p>
  <p>The Service Discovery enables applications to find services. Some applications, however, may be pre-programmed with specific services. Others may want to find what services are available.</p>
  <p>Therefore:</p>
  <ul>
    <li>The use of the Service Discovery is OPTIONAL for applications wishing to use services.</li>
    <li>The GotAPI SHALL support the Service Discovery if the GotAPI-4 is supported.</li>
    <li>The GotAPI-1 SHALL support the Requests and Responses for the Service Discovery if GotAPI-4 is supported. This is to ensure consistent interface for application developers.</li>
    <li>GotAPI-4 SHALL support the protocol (the data container format) between the GotAPI Server and the Extension Plug-Ins. This is to ensure consistent interface for Extension Plug-In developers.</li>
  </ul>
  <p>Example of Service Discovery</p>
  <p>Editor’s Note: This example may remain in this section or moved to an Annex later. Alternatively, the description may be described in a more generalized form to remain in this section as a part of the normative specification, not as an example.</p>
  <p>The following example is based on an implementation on Android.</p>

	<figure id="6" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>Service Discovery Procedure</b></figcaption>
	<img src="images/Service_Discovery.png" style="width: 80%; align: center;"/>
	</figure>

  <p>Terminology:</p>
  <ul>
    <li>Explicit Intents are Intents with a specific application identifier, enabling the sending application to specify the exact receiving application to be run. </li>
  </ul>
  <p>Description of operation:</p>
  <p>General operation: </p>
  <ol>
    <li>the GotAPI Server has received a Service Discovery request from an application over the GotAPI-1 interface, the GotAPI Server sends a Service Discovery Command to each of the installed Extension Plug-Ins using the protocol (the data container format) of GotAPI-4 over an Explicit Intent. Note: The Plug-In Discovery has already found Extension Plug-Ins that are installed on the device.</li>
    <li>an Extension Plug-In receives a Service Discovery Command from the GotAPI Server, the Extension Plug-In checks the availability of the service that is requested by the Service Discovery. When the Extension Plug-In completes checking the availability of the service, the Extension Plug-In sends a response to the GotAPI Server over an Explicit Intent.</li>
    <li>the GotAPI Server has received responses from all of the Extension Plug-Ins, the GotAPI Server returns the result to the application as one response.</li>
  </ol>
  <p>Multiple plug-ins and asynchronous responses: </p>
  <p>Since there can be multiple Extension Plug-Ins installed on the device, each response is sent to the GotAPI Server asynchronously.  </p>
  <p>White List: </p>
  <p>When an Extension Plug-In sends a response, it uses an Explicit Intent to the pre-defined GotAPI Server that is listed in the White List. The White List is provided in each Extension Plug-In by the provider of the Extension Plug-In. The White List enables Extension Plug-Ins to send responses only to the GotAPI Server applications that are listed in the list and prevents Extension Plug-Ins from sending responses to unknown GotAPI Servers. This is to disable spoofed GotAPI Servers to use Extension Plug-Ins.</p>
  <p>Consolidated response from GotAPI Server: </p>
  <p>After consolidating the responses that are sent from multiple Extension Plug-Ins asynchronously, the GotAPI Server sends a response to the originating application with the information that are received from the Extension Plug-Ins.</p>
  <p>Stateless: </p>
  <p>The GotAPI Server itself does not keep the status of the services that are discovered by the Service Discovery Command, keeping GotAPI Server stateless in terms of services. It is the sole responsibility of the applications that have received the service status information how to keep or use it. </p>
  <p>Note: As described in the Plug-In Discovery section, the GotAPI Server must keep the up-to-date status of the Extension Plug-Ins that are installed on the device.</p>
	</section>
	
	<section id="7.3.2.4.3">
  <h5>Approval</h5>
  <p>After an application is registered by the GotAPI Authentication Server through user permission, the application is eligible for accessing Plug-Ins. To ensure protecting user’s data and privacy, however, before the user is able to access the Plug-Ins using the application, the user shall be able to authorize the application to access the Plug-In and the device. To enable this requirement:</p>
  <ul>
    <li>The application SHOULD be authorized to access the Plug-In and the device by the user.</li>
    <li>The GotAPI-1 SHALL support the Requests and Responses for authorization to access an application to a Plug-In via user authorization. This is to ensure consistent interface for application developers.</li>
    <li>The GotAPI-1 SHALL support the Requests and Responses for authorization to access an application to a Plug-In via user authorization if GotAPI-4 is supported</li>
  </ul>
  <p>Editor’s Note: Whether we should specify the authorization mechanism for GotAPI-4 and Plug-Ins is TBD.</p>
  <p>Example of the authorization mechanism for GotAPI-4 and Plug-Ins, based on an implementation on Android:</p>
  <p>Editor’s Note: This example may remain in this section or moved to an Annex later. Alternatively, the description may be described in a more generalized form to remain in this section as a part of the normative specification, not as an example.</p>
  <p>Plug-In API Access Request: Typically after the application performing Plug-In Discovery to get the information of the installed Plug-Ins, the application requests a Plug-In API Access Request to the GotAPI Server over the GotAPI-1 interface.</p>
  <p>Application Registration to Plug-Ins: If the request is made for the first time, the GotAPI Server requests Application Registration to the targeted Plug-In over the GotAPI-4 with the Application Identifier such as the package name. Then the Plug-In registers the application and creates a client_id which is an identifier of the application managed by the Plug-In. </p>
  <p>Client_id and White List: The Plug-In returns the client_id to the GotAPI Server over the GotAPI-4 interface, using an Explicit Intent. The Explicit Intent with the White List in the Plug-In disables providing a client_id to a spoofed GotAPI Server (the same mechanism as in the Plug-In Discovery).</p>
  <p>Access Token and User Authorization: The GotAPI Server requests an access token with the client_id. Upon receiving the access token request, the Plug-In pops up a dialog box to the user, which prompts the user to select the permission. If the user permits the access request, the Plug-In creates an access token and returns it to the GotAPI Server. Note that an access token is used only between the GotAPI Server and Plug-Ins over the GotAPI-4 interface.</p>
  <p>Accessing API using access token: When the GotAPI Server receives the access token from the Plug-In, the GotAPI Server passes the API Access Request from the application to the Plug-In over GotAPI-4 with the access token. When the GotAPI Server receives the response form the Plug-In, the GotAPI Server passes the response from the Plug-In to the application over the GotAPI-1 interface.</p>
  <p>Reusable access token and life time: Once the GotAPI Server receives an access token for an application, the GotAPI Server doesn't need to request another Application Registration or an access token. The GotAPI Server can continue using the same access token for a while as long as the Plug-In accepts the access token. Access tokens are given a life time, so that the same access token can be used before the life time is expires. After the life time is expired, the GotAPI must request another access token using the same procedure. </p>

	<figure id="6" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>Example of Plugin Approval</b></figcaption>
	<img src="images/Plugin_Aproval.png" style="width: 80%; align: center;"/>
	</figure>

  <p>Editor’s Note: The green texts in the diagram above are just sample code. What protocol/format is appropriate for the GotAPI-4 is TBD. The sample code will be updated when the final protocol/format is agreed.</p>
	</section>

<section id="7.3.2.4.4">
  <h5>Data Forwarding</h5>
  <p>Once a connection between the GotAPI Server and the targeted Extension Plug-In is established (i.e., GotAPI-4 Plug-In Discovery (optional) and GotAPI-4 Approval have been successfully completed), the application can communicate with the targeted Extension Plug-In. The data transferred between the application and the Extension Plug-In pass-through the GotAPI Server.</p>
  <p>The GotAPI-4 Data Forwarding defines the protocol (the data container format) between the GotAPI Server and the Extension Plug-Ins that are connected with external devices or internal enablers.</p>
  <p>Example:</p>
  <p>The following description and Figure-4 show how the pass-through mechanism of the Data Forwarding works:</p>
  <p>An application sends a request to the GotAPI Server using an HTTP connection with some parameters in accordance with the GotAPI-1. The GotAPI Server converts the request to the data format (protocol) in accordance with the GotAPI-4 Data Forwarding specification. Then the GotAPI Server conveys the converted data to the targeted Extension Plug-in using the OS adaptation, such as Intent for Android.  Finally, the Extension Plug-In invokes the APIs with the received and re-converted data. The APIs are implemented in the Extension Plug-In. This mechanism allows requests and responses between applications and external or internal entities to be passed-through to the APIs.</p>
	
	<figure id="7" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>Pass-through mechanism of Data Forwarding</b></figcaption>
	<img src="images/Data_Forwarding_PassThru.png" style="width: 80%; align: center;"/>
	</figure>

  <p>In order to get binary data from the Plug-Ins, the Temporary Server Feed (TSF) mechanism may be used:</p>
  <ul>
    <li>An application sends a request to the GotAPI Server over the GotAPI-1 interface. </li>
    <li>The GotAPI Server passes the request to the Plug-In over the GotAPI-4 interface. </li>
    <li>When the Plug-In receives the request, the Plug-In creates a non-predictable random URI for the binary data that is requested, and associates the URI with the binary data. </li>
    <li>The Plug-In sends a response with the URI and additional information (if needed) to the GotAPI Server over the GotAPI-4 interface, and the GotAPI Server passes the response to the application over the GotAPI-1 interface.</li>
    <li>Receiving the URI, the application accesses the URI in order to get the requested binary data from the Plug-In directly. The Plug-In works as a Web server.</li>
    <li>The Plug-In discards the URI after the application gets the binary data or a preset life time expires for the purpose of security.</li>
    <li>The URI may use the same IP address as the GotAPI Server but with a different port number. This enables the Plug-In to be a separate application than the GotAPI Server application.</li>
  </ul>
	
	<figure id="8" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>TSF mechanism for GotAPI-4</b></figcaption>
	<img src="images/TSF_mechanism.png" style="width: 80%; align: center;"/>
	</figure>

  <p>Editor’s Note: The JSON data and some URIs in the diagram above are just sample code. What protocol/format is appropriate for the GotAPI-4 inetrface is TBD. The sample code will be updated when the final protocol/format is agreed.</p>
  <p>Editor’s Note: The specifics of Plug-Ins are out of the scope of GotAPI. Nonetheless, we may want to provide guidance for Plug-In developers. For such purpose the following requirements are identified. This will help provide consistency for application developers to use this mechanism.</p>
  <ul>
    <li>A Plug-In MAY support the TSF mechanism. </li>
    <li>If a Plug-In supports the TSF mechanism, the Plug-In SHALL support the procedure above.</li>
  </ul>
	</section>
	</section>
	</section>
	</section>

	<section id="7.4">
  <h2>Security Considerations</h2>

<section id="7.4.1">
  <h3>Authorization</h3>
  <p>GotAPI may be used to expose APIs which provide access to sensitive device functions or data. This presents a risk of exposure of device functions and data without informing the user or obtaining consent, or from rogue applications that seek to fraudulently access GotAPI based APIs. Note that whether a specific GotAPI based API is considered to expose sensitive functions or data must be clarified by the specification for the GotAPI based API. The following requirements are intended to address the general risk of unauthorized access to GotAPI based APIs:</p>
  <ul>
    <li>If sensitive functions or data are exposed by a GotAPI based API, the GotAPI Server  SHALL verify API access permission for the specific application, before providing API service.</li>
    <li>GotAPI Servers SHALL provide at least one means of managing API access permissions, including one or more of:</li>
    <ul>
      <li>Permissions that are remotely managed via OMA Device Management [OMA DM] using the GotAPI Permissions managed object [GotAPI MO]</li>
      <li>Permissions that are remotely managed via implementation-specific means</li>
      <li>Permissions that are managed by the user through GotAPI Authorization Server user interfaces</li>
    </ul>
  </ul>
  <p>GotAPI Servers SHALL support access permissions granted on a variety of bases, including:</p>
  <ul>
    <li>Free access, i.e. no permission required</li>
    <li>Global access, meaning that once access is granted to any device or application, all further requests are allowed</li>
    <li>Device-specific access, meaning that access is authorized on a per-device basis, including local device access, subnet-based access (e.g. to enable access by any device in a private network), or specific devices by source IP address</li>
    <li>Application-specific access, meaning that access is authorized for each application which can be reliably identified using:</li>
    <ul>
      <li>For web-based applications, the HTTP Origin header</li>
      <li>For native applications, an application identifier as specific to the native platform</li>
    </ul>
  </ul>
</section>

<section id="7.4.2">
  <h3>Confidentialty and Integrity </h3>
  <p>GotAPI is intended to support securely-exposed APIs to help ensure confidentiality and integrity of API operations when needed. When protected by transport layer security (e.g. TLS 1.2), GotAPI based APIs require consideration of the following potential issues:</p>
  <ul>
    <li>GotAPI Servers are unlikely to be provisionable with server certificates that can be validated by clients. For APIs exposed over TLS, this will likely result at least in certificate warnings at the client, and possibly failure of the client to connect to the GotAPI Server.</li>
  </ul>
  <p>Other means of ensuring confidentiality and integrity of API operations may also be supported, such as API request/response payload encryption based upon pre-shared or dynamically established encryption keys. </p>
</section>

<section id="7.4.3">
  <h3>Immunity from Attack</h3>
	
<section id="7.4.3.1">
  <h4>Traffic based attack </h4>
  <p>Since it exposes a service on host devices, GotAPI by nature consumes device resources in handling service requests. This presents a risk if the GotAPI Server is not adequately protected from rogue applications that may launch intrusion or denial-of-service (DOS) attacks on the host device, which may cause GotAPI Server host device instability, unusability, or excessive resource consumption (e.g. battery). Such attacks can involve excessive API requests or malformed API requests. The following requirements are intended to address these risks:</p>
  <ul>
    <li>GotAPI Servers SHALL limit API request volume to an unspecified maximum rate, in order to limit exposure to DOS attacks. GotAPI Servers SHALL temporarily disable API permissions for applications that are suspected of excessive API requests.</li>
    <li>GotAPI Servers SHALL ensure the validity of API requests prior to processing them. GotAPI Servers SHALL temporarily disable API permissions for applications that are suspected of sending maliciously malformed API requests.</li>
  </ul>
  <p>GotAPI Servers SHALL provide a means for users to be informed of applications that have been suspended from API access due to suspected security violations, and a means to re-authorize API access for those applications.</p>
</section>

<section id="7.4.3.2">
  <h4>GotAPI Server spoofing attack</h4>
  <p>If the underling operating system allows for an application to kill other applications that are running in the background , it is possible for a bogus application to spoof the genuine GotAPI Server and provide fake or harmful information to the application. An attack can be made by 1) terminating the running GotAPI Server and 2) taking over the port that the GotAPI Server has been listening to. If this attack is made, the application that is communicating only through the port, has no way to know that the GotAPI Server is spoofed. This type of attack is called the GotAPI Server spoofing attack. To prevent this attack, the application must be able to authenticate the GotAPI Server that it is communicating with. </p>
  <p>There are two approaches possible to enable such authentication of the genuine GotAPI Server.</p>
  <ol>
    <li>not to embed any credentials in the GotAPI application, and</li>
    <li>to embed credentials in the GotAPI application</li>
  </ol>
  <p>The first approach is based on other trust that may be provided by the operating system and/or the application market ecosystem. Many application market ecosystems provide an Application ID for an application that is guaranteed to be unique in the ecosystem including the operating system and the devices. An Application ID may be used for the trust of the GotAPI application for the authenticity. This approach, however, may be a solution depending on the operating system.</p>
  <p>The second approach is based on the credential embedded in the application as the trust. It typically requires an external server to verify the authenticity of the credential of the GotAPI Server for the application. The challenge of this approach is how to protect the credential that is embedded in the GotAPI application from attackers who are able to reverse engineer the application. If the same credential is embedded in all the applications and distributed to many devices and if the credential is compromised on one device, all the devices implementing the application would be compromised.</p>
</section>
<section id="7.4.3.3">
  <h4>HMAC server authentication using trusted Application ID for the GotAPI Server spoofing attack</h4>
  <p>This counter measure works for a platform and a UA that satisfy the following requirements. This is based on the trust provided by the Application ID of the native application, and not embedding any credentials in the native application.</p>
  <ul>
    <li>The Application ID is unique and trusted, which is guaranteed by the platform.</li>
    <li>The execution environment, e.g., UA, provides a one-way channel for an application to connect directly and send messages to a native application by designating its Application ID, e.g. a URI scheme. </li>
    <li>The application can be connected exclusively and securely with a native application by designating its Application ID. Namely, there is no eavesdropping, no man-in-the-middle, or no spoofed destination in the channel from the application to the destination native application.</li>
  </ul>
  <p>We call this type of channel as “Trusted Channel”.</p>
  <p>Note: Intent URI Scheme for Android satisfies all these requirements. The destination is designated by the package name of the native application to which a web applications attempts to send messages.</p>
  <p>Other assumptions are:</p>
  <ul>
    <li>The HTTP channel may be eavesdropped (*).</li>
    <li>Any application can terminate other applications that are running in the background and take over the port that the application is listening to.</li>
    <li>The application knows the Application ID of the genuine GotAPI server. The Application ID is provided to the application out of the band in a trusted manner.</li>
  </ul>
  <p>Note: It has been shown that eavesdropping is not possible over the GotAPI-1 interface on Android unless the device is rooted. Nonetheless, this assumption is introduced here because there may be a way for eavesdropping the HTTP connection that we are not aware of.</p>
  <p>If the one-way Trusted Channel is available, the GotAPI Server spoofing attack is prevented using the HMAC server authentication as follows:</p>
  <p>Shared key distribution using the Trusted Channel:</p>
  <ol>
    <li>application generates a key, K, composed of unpredictable random characters, and stores the key securely.</li>
    <li>application sends the key, K, to the genuine GotAPI Server through the Trusted Channel designating the Application ID of the genuine GotAPI Server. The application knows the genuine GotAPI Server application’s Application ID in an out-of-band trusted channel.</li>
    <li>genuine GotAPI Server stores the key securely.</li>
  </ol>
  <p>HMAC calculation and sending messages through the GotAPI-1 Interface:</p>
  <ol>
    <li>the application sends a request, it creates a nonce, N, which is a random digit series enough long not to be predicted, and, then, it sends the message, M, and the nonce, N, through the GotAPI-1 Interface.</li>
    <li>the genuine GotAPI Server receives the request, it calculates an HMAC, h'=HMAC(K,N), with the nonce, N, and the key, K, that the application distributed through the Trusted Channel before.</li>
    <li>genuine GotAPI Server sends a response with the HMAC, h', and the response message, m, to the application through the GotAPI-1 interface.</li>
    <li>application calculates an HMAC, H'=HMAC(K, N), and  it checks if H' is equal to h' that is received from the GotAPI Server. If equal, verification of the GotAPI Server authentication is successful and the GotAPI Server verifies that the response has surely been sent by the genuine GotAPI Server. If not, application determines that the server that sent the message is spoofed.</li>
  </ol>
  <p>The figure below presents a normal case of the HMAC server authentication.</p>

	<figure id="9" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>HMAC server authentication – Normal Case</b></figcaption>
	<img src="images/HMAC_server_authentication_Normal_Case.png" style="width: 80%; align: center;"/>
	</figure>

  <p>The figure below presents a spoofing attack case of the HMAC server authentication.</p>
  <p>When a bogus server attempts to spoof the genuine GotAPI Server, the bogus server can't calculate a right HMAC because it never knows the key, K, generated by the application.</p>
		
	<figure id="9" style="display: table; width: 100%; text-align: center;">
	<figcaption><b>HMAC server authentication – Spoofing Attack Case</b></figcaption>
	<img src="images/HMAC_server_authentication_Spoofing_Attack_Case.png" style="width: 80%; align: center;"/>
	</figure>
	
  <p>Since GotAPI Server spoofing is an easy-to-do attack, GotAPI implementations needs to protect it from the attack.</p>
  <ul>
    <li>If the one-way Trusted Channel is available in the device from the application to the genuine GotAPI Server application, the GotAPI Server SHOULD support the HMAC server authentication described in this section to prevent the GotAPI Server spoofing attack. </li>
    <li>If the HMAC server authentication is supported, the GotAPI Server SHALL support SHA-256 for the hash algorithm for calculating an HMAC.</li>
    <li>The GotAPI Server SHALL be able to support and respond to the application regardless of the application being using the HMAC server authentication or not. But the GotAPI Server SHALL NOT respond to applications which have not been authenticated by the Authentication Server through the GotAPI-2 Interface.</li>
    <li>The GotAPI Server SHALL accept keys sent by authenticated applications anytime. The GotAPI Server SHALL calculate an HMAC using the new key that was most recently provided from the web application.</li>
  </ul>
  <p>Recommendations for applications (non-normative)</p>
  <ul>
    <li>The use of the HMAC server authentication is OPTIONAL for an application.</li>
    <li>An application SHALL generate a new key, K, and use it whenever the application is invoked.</li>
    <li>An application SHALL create a new nonce every time it sends a request to the GotAPI Server.</li>
  </ul>
	</section>
	
	<section id="8">
  <h1>Technical Specifications</h1>

	<section id="8.1">
  <h2>GotAPI Server</h2>

	<section id="8.1.1">
  <h3>Availability API on the GotAPI-1 Interface</h3>
  <p>This API provides the status whether the GotAPI Server is running or not. The application uses this API before the application authorization on the GotAPI-2 Interface. The GotAPI Server SHALL accept and respond to the requests for this API coming from any application even if the application authorization on the GotAPI Server has not been completed.</p>
	<table>
		<caption>Definition of the request</caption>
		<thead>
			<th></th>
			<th>Definitions</th>
		</thead>
		<tr>
			<td>Method</td>
			<td>HTTP GET (REST)</td>
		</tr>
		<tr>
			<td>Request URL</td>
			<td>http://127.0.0.1:4035/gotapi/availability<br/>
			https://127.0.0.1:4036/gotapi/availability</td>
		</tr>
		<tr>
			<td>Parameters</td>
			<td>none</td>
		</tr>
	</table>

	<table>
		<caption>Definition of the response</caption>
		<thead>
			<th></th>
			<th>Definitions</th>
		</thead>
		<tr>
			<td>MIME-Type</td>
			<td>application/json</td>
		</tr>
		<tr>
			<td>HTTP status</td>
			<td>200 OK</td>
		</tr>
	</table>
	

	</section>
	</section>
	
</body>
</html>